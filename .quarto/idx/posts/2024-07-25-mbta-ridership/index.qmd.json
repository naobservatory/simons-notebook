{"title":"Identifying promising MBTA stations for swab sampling: MBTA Ridership","markdown":{"yaml":{"title":"Identifying promising MBTA stations for swab sampling: MBTA Ridership","subtitle":"How many passengers use different MBTA stations?","author":"Simon Grimm","date":"2024-07-25","categories":["MBTA","Swab sampling"],"toc":true,"draft":true,"format":{"html":{"code-fold":true,"code-tools":true,"code-link":true,"df-print":"paged","fig-format":"png","fig-dpi":600}},"jupyter":"venv","cap-location":"bottom"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nAs part of our [swab sampling pilot](https://naobservatory.org/blog/investigating-the-sensitivity-of-pooled-swab-sampling-for-pathogen-early-detection) project, we want to identify stations where we can collect a lot of swab samples in a short amount of time. One way to identify these stations is to look at the number of passengers that enter each station, which the [MBTA provides](https://mbta-massdot.opendata.arcgis.com/datasets/7859894afb5641ce91a2bb03599fdf5b/about). They give the number of passengers that enter a gated station every 30 minutes. Crucially, this doesn't tell us how many people leave the station, which would be useful to understand full passenger volume of a station.\n\n# Station ridership\n\n## Red line\n\nThe red line is closest to the office and MIT and thus the obvious candidate for sampling. Let's take a look at the daily ridership, averaged over the month of June 2024, for the red line stations closest to the SecureBio office (Porter, Central, Kendall/MIT, Charles/MGH, Park Street, and Downtown Crossing).\n\n```{python}\n#| label: import functions and data\n#| echo: false\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport seaborn as sns\n\nridership_2024 = pd.read_csv(\"data/GSE_2024.csv\")\nridership_2024[\"date_dt\"] = pd.to_datetime(ridership_2024[\"service_date\"])\nreference_date = pd.to_datetime(\"1800-06-01\")  # reference date is used as a placeholder, set to an implausible value\nridership_2024[\"time_dt\"] = pd.to_datetime(reference_date.strftime('%Y-%m-%d') + ' ' + ridership_2024[\"time_period\"].str.strip(\"()\"))\n\n\n# Data represents ridership over the half hour starting at the given time. Adding 15 minutes to create correct center of interval.\nridership_2024[\"time_dt\"] = ridership_2024[\"time_dt\"] + pd.Timedelta(minutes=15)\n\nPRINT = None\n```\n\n```{python}\n#| label: fig-red-line-analysis\nplt.figure(figsize=(12, 4), dpi=600)\ntarget_stations = [\"Porter\", \"Harvard\", \"Central\", \"Kendall/MIT\", \"Charles/MGH\", \"Park Street\", \"Downtown Crossing\"]\n\n\nridership_2024[\"date_dt\"] = pd.to_datetime(ridership_2024[\"service_date\"])\nreference_date = pd.to_datetime(\"1800-06-01\")  # reference date is used as a placeholder, set to an implausible value\nridership_2024[\"time_dt\"] = pd.to_datetime(reference_date.strftime('%Y-%m-%d') + ' ' + ridership_2024[\"time_period\"].str.strip(\"()\"))\nmorning_peak_rides = {}\nevening_peak_rides = {}\n\n# Data represents ridership over the half hour starting at the given time. Adding 15 minutes to create correct center of interval.\nridership_2024[\"time_dt\"] = ridership_2024[\"time_dt\"] + pd.Timedelta(minutes=15)\n\n\nred_line_2024 = ridership_2024[ridership_2024[\"route_or_line\"] == \"Red Line\"]\njune_2024 = red_line_2024[red_line_2024[\"date_dt\"].dt.month == 6]\nstations = june_2024[\"station_name\"].unique()\nfor station in stations:\n    if station in target_stations:\n        june_station = june_2024[june_2024[\"station_name\"] == station]\n        mean_use_per_interval = june_station.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership_morning = mean_use_per_interval[mean_use_per_interval[\"time_dt\"].dt.hour.between(1, 10)][\"gated_entries\"].max()\n        max_usership_evening = mean_use_per_interval[mean_use_per_interval[\"time_dt\"].dt.hour.between(16, 23)][\"gated_entries\"].max()\n        morning_peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership_morning]\n        evening_peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership_evening]\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=station)\n\n    else:\n        if PRINT:\n            print(station)\nax = plt.gca()\nplt.legend()\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval for Red Line stations in June 2024\")\nplt.show()\n\n# Morning peaks:\n\nmorning_peak_ride_porter = round(morning_peak_rides[\"Porter\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_porter = morning_peak_rides[\"Porter\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nmorning_peak_ride_central = round(morning_peak_rides[\"Central\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_central = morning_peak_rides[\"Central\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nmorning_peak_ride_kendall = round(morning_peak_rides[\"Kendall/MIT\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_kendall = morning_peak_rides[\"Kendall/MIT\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nmorning_peak_ride_harvard = round(morning_peak_rides[\"Harvard\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_harvard = morning_peak_rides[\"Harvard\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n\nevening_peak_ride_kendall = round(evening_peak_rides[\"Kendall/MIT\"][\"gated_entries\"].values[0])\nevening_peak_ride_time_kendall = evening_peak_rides[\"Kendall/MIT\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nevening_peak_ride_harvard = round(evening_peak_rides[\"Harvard\"][\"gated_entries\"].values[0])\nevening_peak_ride_time_harvard = evening_peak_rides[\"Harvard\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nevening_peak_ride_charles = round(evening_peak_rides[\"Charles/MGH\"][\"gated_entries\"].values[0])\nevening_peak_ride_time_charles = evening_peak_rides[\"Charles/MGH\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n\n\n\n```\n\n\nCentral, Harvard, and Porter stations see the most ppl entering stations in the morning due to commuters going into the city (`{python} morning_peak_ride_central`, `{python} morning_peak_ride_harvard`, and `{python} morning_peak_ride_porter` from 8:30-9:00, respectively). Kendall/MIT, Charles/MGH, and Harvard see the most people entering in the evening (`{python} evening_peak_ride_kendall`, `{python} evening_peak_ride_charles`, and `{python} evening_peak_ride_harvard` from 17:00-17:30, respectively). People who take the T from a commuter station in the evening likely arrived at the same station in the evening. We can thus assume that the evening bump in ridership for Kendall and Harvard can be added to the morning bump.\n\nBased on the data here, Kendall and Harvard station all seem like good stations to do sampling in the morning.\n\n## Green line\n\nThe green line is fairly close to the office (two stations away). Looking at @fig-mbta-station-plan, the four Green line stations closest to the nearest Red line station are Government Center, Haymarket, Boylston, and Copley.\n\n![MBTA Subway Map (2013)](img/2013_unofficial_MBTA_subway_map_by_Michael_Kvrivishvili.png){#fig-mbta-station-plan}\n\n```{python}\n#| label: fig-green-line-analysis\n\nplt.figure(figsize=(12, 4), dpi=600)\ntarget_stations = [\"Government Center\", \"Haymarket\", \"Boylston\", \"Copley\"]\npeak_rides = {}\n\n\ngreen_line_2024 = ridership_2024[ridership_2024[\"route_or_line\"] == \"Green Line\"]\njune_2024 = green_line_2024[green_line_2024[\"date_dt\"].dt.month == 6]\nstations = june_2024[\"station_name\"].unique()\nfor station in stations:\n    if station in target_stations:\n        june_station = june_2024[june_2024[\"station_name\"] == station]\n        mean_use_per_interval = june_station.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership = mean_use_per_interval[\"gated_entries\"].max()\n        peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership]\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=station)\n\n    else:\n        if PRINT:\n            print(f\"{station} is more than three stations away from Kendall close to Kendall\")\nax = plt.gca()\nplt.legend()\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\n\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval for Green Line stations in June 2024\")\nplt.show()\n\npeak_ride_copley = round(peak_rides[\"Copley\"][\"gated_entries\"].values[0])\npeak_ride_time_copley = peak_rides[\"Copley\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_haymarket = round(peak_rides[\"Haymarket\"][\"gated_entries\"].values[0])\npeak_ride_time_haymarket = peak_rides[\"Haymarket\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n\n\n```\n\n\nCopley and Government Center see the most ridership (`{python} peak_ride_copley`) and `{python} peak_ride_haymarket` at `{python} peak_ride_time_copley`, respectively at from 17:00 to 17:30. Again, the same pattern is visible where many people enter stations in the evening, and thus likely leave the station in the evening.\n\n## Orange line\n\nFinally, let's look at the Orange line. The Orange line is the furthest away from the office, but it is still only 3 stations away. Let's again look at the four Orange line stations closest to the office. Additionally I include Back Bay station as that station has a fairly big entrance hall which could be suitable for sampling:\n\n![Back Bay Station](img/back_bay-2x.jpg){width=60%}\n\n```{python}\n#| label: fig-orange-line-analysis\n\nplt.figure(figsize=(12, 4), dpi=600)\ntarget_stations = [\"Tufts Medical Center\", \"Haymarket\", \"Chinatown\", \"State Street\", \"Back Bay\"]\npeak_rides = {}\n\norange_line_2024 = ridership_2024[ridership_2024[\"route_or_line\"] == \"Orange Line\"]\njune_2024 = orange_line_2024[orange_line_2024[\"date_dt\"].dt.month == 6]\nstations = june_2024[\"station_name\"].unique()\nfor station in stations:\n    if station in target_stations:\n        june_station = june_2024[june_2024[\"station_name\"] == station]\n        mean_use_per_interval = june_station.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership = mean_use_per_interval[\"gated_entries\"].max()\n        peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership]\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=station)\n\n    else:\n        if PRINT:\n            print(station)\nax = plt.gca()\nplt.legend()\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval for Orange Line stations in June 2024\")\nplt.show()\n\npeak_ride_back_bay = round(peak_rides[\"Back Bay\"][\"gated_entries\"].values[0])\npeak_ride_time_back_bay = peak_rides[\"Back Bay\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_state_street = round(peak_rides[\"State Street\"][\"gated_entries\"].values[0])\npeak_ride_time_state_street = peak_rides[\"State Street\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n```\n\nHere Back Bay and State Street look great, with a peak ridership of `{python} peak_ride_back_bay` and `{python} peak_ride_state_street` from 17:00 to 17:30.\n\n\n## North and South Station\n\nFinally, let's look at North Station and South Station. Given that they are connected to the Amtrak network, they might see a lot of traffic. Additionaly we are currently in conversation with the administrators of both stations to do sampling there (though sampling would probaly take place in the train station, not in the subway station).\n\n\n```{python}\n#| label: fig-north-south-station-analysis\n\ntarget_stations = [\"North Station\", \"South Station\"]\nplt.figure(figsize=(12, 4), dpi=600)\n\npeak_rides = {}\n\njune_ridership = ridership_2024[ridership_2024[\"date_dt\"].dt.month == 6]\n\nfor station in target_stations:\n    station_ridership = june_ridership[june_ridership[\"station_name\"] == station]\n    lines_in_station = station_ridership[\"route_or_line\"].unique()\n    for line in lines_in_station:\n        line_ridership = station_ridership[station_ridership[\"route_or_line\"] == line]\n        mean_use_per_interval = line_ridership.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership = mean_use_per_interval[\"gated_entries\"].max()\n\n        peak_rides[(station, line)] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership]\n\n        line_to_sns_color_dict = {\"Green Line\": \"#58ac6c\", \"Orange Line\": \"#f79646\", \"Red Line\": \"#d62728\", \"Silver Line\": \"#647c9a\"}\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=f\"{station} ({line})\", color=line_to_sns_color_dict[line])\n\nax = plt.gca()\nplt.legend()\n\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval at North and South Stations in June 2024\")\n\npeak_ride_north_green = round(peak_rides[\"North Station\", \"Green Line\"][\"gated_entries\"].values[0])\npeak_ride_time_north_green = peak_rides[\"North Station\", \"Green Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_north_orange = round(peak_rides[\"North Station\", \"Orange Line\"][\"gated_entries\"].values[0])\npeak_ride_time_north_orange = peak_rides[\"North Station\", \"Orange Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_south_red = round(peak_rides[\"South Station\", \"Red Line\"][\"gated_entries\"].values[0])\npeak_ride_time_south_red = peak_rides[\"South Station\", \"Red Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_south_silver = round(peak_rides[\"South Station\", \"Silver Line\"][\"gated_entries\"].values[0])\npeak_ride_time_south_silver = peak_rides[\"South Station\", \"Silver Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n```\n\nFor both stations and lines, peak traffic is again at 17:00 to 17:30, with `{python} peak_ride_north_green` and `{python} peak_ride_north_orange` riders at North Station's Green and Orange line, and `{python} peak_ride_south_red` and `{python} peak_ride_south_silver` riders at South Station's Red and Silver line, respectively.\n\n# Conclusion\n\nIn summary the following stations seem most promising:\n\n -  **Red line**: Kendall, Harvard, and Charles/MGH\n -  **Green line**: Boylston and Government Center\n -  **Orange line**: Back Bay and State Street\n -  North and South Station\n\nAs a next step I will visit the most promising stations and check i) how many separate fare gates each station has, and ii) how much space there is for sampling.","srcMarkdownNoYaml":"\n# Introduction\n\nAs part of our [swab sampling pilot](https://naobservatory.org/blog/investigating-the-sensitivity-of-pooled-swab-sampling-for-pathogen-early-detection) project, we want to identify stations where we can collect a lot of swab samples in a short amount of time. One way to identify these stations is to look at the number of passengers that enter each station, which the [MBTA provides](https://mbta-massdot.opendata.arcgis.com/datasets/7859894afb5641ce91a2bb03599fdf5b/about). They give the number of passengers that enter a gated station every 30 minutes. Crucially, this doesn't tell us how many people leave the station, which would be useful to understand full passenger volume of a station.\n\n# Station ridership\n\n## Red line\n\nThe red line is closest to the office and MIT and thus the obvious candidate for sampling. Let's take a look at the daily ridership, averaged over the month of June 2024, for the red line stations closest to the SecureBio office (Porter, Central, Kendall/MIT, Charles/MGH, Park Street, and Downtown Crossing).\n\n```{python}\n#| label: import functions and data\n#| echo: false\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.dates as mdates\nimport seaborn as sns\n\nridership_2024 = pd.read_csv(\"data/GSE_2024.csv\")\nridership_2024[\"date_dt\"] = pd.to_datetime(ridership_2024[\"service_date\"])\nreference_date = pd.to_datetime(\"1800-06-01\")  # reference date is used as a placeholder, set to an implausible value\nridership_2024[\"time_dt\"] = pd.to_datetime(reference_date.strftime('%Y-%m-%d') + ' ' + ridership_2024[\"time_period\"].str.strip(\"()\"))\n\n\n# Data represents ridership over the half hour starting at the given time. Adding 15 minutes to create correct center of interval.\nridership_2024[\"time_dt\"] = ridership_2024[\"time_dt\"] + pd.Timedelta(minutes=15)\n\nPRINT = None\n```\n\n```{python}\n#| label: fig-red-line-analysis\nplt.figure(figsize=(12, 4), dpi=600)\ntarget_stations = [\"Porter\", \"Harvard\", \"Central\", \"Kendall/MIT\", \"Charles/MGH\", \"Park Street\", \"Downtown Crossing\"]\n\n\nridership_2024[\"date_dt\"] = pd.to_datetime(ridership_2024[\"service_date\"])\nreference_date = pd.to_datetime(\"1800-06-01\")  # reference date is used as a placeholder, set to an implausible value\nridership_2024[\"time_dt\"] = pd.to_datetime(reference_date.strftime('%Y-%m-%d') + ' ' + ridership_2024[\"time_period\"].str.strip(\"()\"))\nmorning_peak_rides = {}\nevening_peak_rides = {}\n\n# Data represents ridership over the half hour starting at the given time. Adding 15 minutes to create correct center of interval.\nridership_2024[\"time_dt\"] = ridership_2024[\"time_dt\"] + pd.Timedelta(minutes=15)\n\n\nred_line_2024 = ridership_2024[ridership_2024[\"route_or_line\"] == \"Red Line\"]\njune_2024 = red_line_2024[red_line_2024[\"date_dt\"].dt.month == 6]\nstations = june_2024[\"station_name\"].unique()\nfor station in stations:\n    if station in target_stations:\n        june_station = june_2024[june_2024[\"station_name\"] == station]\n        mean_use_per_interval = june_station.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership_morning = mean_use_per_interval[mean_use_per_interval[\"time_dt\"].dt.hour.between(1, 10)][\"gated_entries\"].max()\n        max_usership_evening = mean_use_per_interval[mean_use_per_interval[\"time_dt\"].dt.hour.between(16, 23)][\"gated_entries\"].max()\n        morning_peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership_morning]\n        evening_peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership_evening]\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=station)\n\n    else:\n        if PRINT:\n            print(station)\nax = plt.gca()\nplt.legend()\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval for Red Line stations in June 2024\")\nplt.show()\n\n# Morning peaks:\n\nmorning_peak_ride_porter = round(morning_peak_rides[\"Porter\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_porter = morning_peak_rides[\"Porter\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nmorning_peak_ride_central = round(morning_peak_rides[\"Central\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_central = morning_peak_rides[\"Central\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nmorning_peak_ride_kendall = round(morning_peak_rides[\"Kendall/MIT\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_kendall = morning_peak_rides[\"Kendall/MIT\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nmorning_peak_ride_harvard = round(morning_peak_rides[\"Harvard\"][\"gated_entries\"].values[0])\nmorning_peak_ride_time_harvard = morning_peak_rides[\"Harvard\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n\nevening_peak_ride_kendall = round(evening_peak_rides[\"Kendall/MIT\"][\"gated_entries\"].values[0])\nevening_peak_ride_time_kendall = evening_peak_rides[\"Kendall/MIT\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nevening_peak_ride_harvard = round(evening_peak_rides[\"Harvard\"][\"gated_entries\"].values[0])\nevening_peak_ride_time_harvard = evening_peak_rides[\"Harvard\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\nevening_peak_ride_charles = round(evening_peak_rides[\"Charles/MGH\"][\"gated_entries\"].values[0])\nevening_peak_ride_time_charles = evening_peak_rides[\"Charles/MGH\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n\n\n\n```\n\n\nCentral, Harvard, and Porter stations see the most ppl entering stations in the morning due to commuters going into the city (`{python} morning_peak_ride_central`, `{python} morning_peak_ride_harvard`, and `{python} morning_peak_ride_porter` from 8:30-9:00, respectively). Kendall/MIT, Charles/MGH, and Harvard see the most people entering in the evening (`{python} evening_peak_ride_kendall`, `{python} evening_peak_ride_charles`, and `{python} evening_peak_ride_harvard` from 17:00-17:30, respectively). People who take the T from a commuter station in the evening likely arrived at the same station in the evening. We can thus assume that the evening bump in ridership for Kendall and Harvard can be added to the morning bump.\n\nBased on the data here, Kendall and Harvard station all seem like good stations to do sampling in the morning.\n\n## Green line\n\nThe green line is fairly close to the office (two stations away). Looking at @fig-mbta-station-plan, the four Green line stations closest to the nearest Red line station are Government Center, Haymarket, Boylston, and Copley.\n\n![MBTA Subway Map (2013)](img/2013_unofficial_MBTA_subway_map_by_Michael_Kvrivishvili.png){#fig-mbta-station-plan}\n\n```{python}\n#| label: fig-green-line-analysis\n\nplt.figure(figsize=(12, 4), dpi=600)\ntarget_stations = [\"Government Center\", \"Haymarket\", \"Boylston\", \"Copley\"]\npeak_rides = {}\n\n\ngreen_line_2024 = ridership_2024[ridership_2024[\"route_or_line\"] == \"Green Line\"]\njune_2024 = green_line_2024[green_line_2024[\"date_dt\"].dt.month == 6]\nstations = june_2024[\"station_name\"].unique()\nfor station in stations:\n    if station in target_stations:\n        june_station = june_2024[june_2024[\"station_name\"] == station]\n        mean_use_per_interval = june_station.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership = mean_use_per_interval[\"gated_entries\"].max()\n        peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership]\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=station)\n\n    else:\n        if PRINT:\n            print(f\"{station} is more than three stations away from Kendall close to Kendall\")\nax = plt.gca()\nplt.legend()\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\n\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval for Green Line stations in June 2024\")\nplt.show()\n\npeak_ride_copley = round(peak_rides[\"Copley\"][\"gated_entries\"].values[0])\npeak_ride_time_copley = peak_rides[\"Copley\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_haymarket = round(peak_rides[\"Haymarket\"][\"gated_entries\"].values[0])\npeak_ride_time_haymarket = peak_rides[\"Haymarket\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n\n\n```\n\n\nCopley and Government Center see the most ridership (`{python} peak_ride_copley`) and `{python} peak_ride_haymarket` at `{python} peak_ride_time_copley`, respectively at from 17:00 to 17:30. Again, the same pattern is visible where many people enter stations in the evening, and thus likely leave the station in the evening.\n\n## Orange line\n\nFinally, let's look at the Orange line. The Orange line is the furthest away from the office, but it is still only 3 stations away. Let's again look at the four Orange line stations closest to the office. Additionally I include Back Bay station as that station has a fairly big entrance hall which could be suitable for sampling:\n\n![Back Bay Station](img/back_bay-2x.jpg){width=60%}\n\n```{python}\n#| label: fig-orange-line-analysis\n\nplt.figure(figsize=(12, 4), dpi=600)\ntarget_stations = [\"Tufts Medical Center\", \"Haymarket\", \"Chinatown\", \"State Street\", \"Back Bay\"]\npeak_rides = {}\n\norange_line_2024 = ridership_2024[ridership_2024[\"route_or_line\"] == \"Orange Line\"]\njune_2024 = orange_line_2024[orange_line_2024[\"date_dt\"].dt.month == 6]\nstations = june_2024[\"station_name\"].unique()\nfor station in stations:\n    if station in target_stations:\n        june_station = june_2024[june_2024[\"station_name\"] == station]\n        mean_use_per_interval = june_station.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership = mean_use_per_interval[\"gated_entries\"].max()\n        peak_rides[station] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership]\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=station)\n\n    else:\n        if PRINT:\n            print(station)\nax = plt.gca()\nplt.legend()\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval for Orange Line stations in June 2024\")\nplt.show()\n\npeak_ride_back_bay = round(peak_rides[\"Back Bay\"][\"gated_entries\"].values[0])\npeak_ride_time_back_bay = peak_rides[\"Back Bay\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_state_street = round(peak_rides[\"State Street\"][\"gated_entries\"].values[0])\npeak_ride_time_state_street = peak_rides[\"State Street\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n```\n\nHere Back Bay and State Street look great, with a peak ridership of `{python} peak_ride_back_bay` and `{python} peak_ride_state_street` from 17:00 to 17:30.\n\n\n## North and South Station\n\nFinally, let's look at North Station and South Station. Given that they are connected to the Amtrak network, they might see a lot of traffic. Additionaly we are currently in conversation with the administrators of both stations to do sampling there (though sampling would probaly take place in the train station, not in the subway station).\n\n\n```{python}\n#| label: fig-north-south-station-analysis\n\ntarget_stations = [\"North Station\", \"South Station\"]\nplt.figure(figsize=(12, 4), dpi=600)\n\npeak_rides = {}\n\njune_ridership = ridership_2024[ridership_2024[\"date_dt\"].dt.month == 6]\n\nfor station in target_stations:\n    station_ridership = june_ridership[june_ridership[\"station_name\"] == station]\n    lines_in_station = station_ridership[\"route_or_line\"].unique()\n    for line in lines_in_station:\n        line_ridership = station_ridership[station_ridership[\"route_or_line\"] == line]\n        mean_use_per_interval = line_ridership.groupby(\"time_dt\")[\"gated_entries\"].mean()\n        mean_use_per_interval = mean_use_per_interval.reset_index()\n        max_usership = mean_use_per_interval[\"gated_entries\"].max()\n\n        peak_rides[(station, line)] = mean_use_per_interval[mean_use_per_interval[\"gated_entries\"] == max_usership]\n\n        line_to_sns_color_dict = {\"Green Line\": \"#58ac6c\", \"Orange Line\": \"#f79646\", \"Red Line\": \"#d62728\", \"Silver Line\": \"#647c9a\"}\n        plt.plot(mean_use_per_interval[\"time_dt\"], mean_use_per_interval[\"gated_entries\"], label=f\"{station} ({line})\", color=line_to_sns_color_dict[line])\n\nax = plt.gca()\nplt.legend()\n\ny_lims = (0, 700)\nfor y in range(y_lims[0], y_lims[1], 100):\n    plt.axhline(y=y, color='gray', linestyle='--', zorder=-1, linewidth=0.5)\n\nplt.ylim(y_lims)\nplt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))\nplt.gca().xaxis.set_major_locator(mdates.HourLocator(interval=2))\nax.spines['top'].set_visible(False)\nax.spines['right'].set_visible(False)\n\nplt.xlabel(\"Time of day\")\nplt.ylabel(\"Number of passengers per half-hour\")\nplt.title(\"Average number of passengers per half-hour interval at North and South Stations in June 2024\")\n\npeak_ride_north_green = round(peak_rides[\"North Station\", \"Green Line\"][\"gated_entries\"].values[0])\npeak_ride_time_north_green = peak_rides[\"North Station\", \"Green Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_north_orange = round(peak_rides[\"North Station\", \"Orange Line\"][\"gated_entries\"].values[0])\npeak_ride_time_north_orange = peak_rides[\"North Station\", \"Orange Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_south_red = round(peak_rides[\"South Station\", \"Red Line\"][\"gated_entries\"].values[0])\npeak_ride_time_south_red = peak_rides[\"South Station\", \"Red Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\npeak_ride_south_silver = round(peak_rides[\"South Station\", \"Silver Line\"][\"gated_entries\"].values[0])\npeak_ride_time_south_silver = peak_rides[\"South Station\", \"Silver Line\"][\"time_dt\"].dt.time.values[0].strftime(\"%H:%M\")\n```\n\nFor both stations and lines, peak traffic is again at 17:00 to 17:30, with `{python} peak_ride_north_green` and `{python} peak_ride_north_orange` riders at North Station's Green and Orange line, and `{python} peak_ride_south_red` and `{python} peak_ride_south_silver` riders at South Station's Red and Silver line, respectively.\n\n# Conclusion\n\nIn summary the following stations seem most promising:\n\n -  **Red line**: Kendall, Harvard, and Charles/MGH\n -  **Green line**: Boylston and Government Center\n -  **Orange line**: Back Bay and State Street\n -  North and South Station\n\nAs a next step I will visit the most promising stations and check i) how many separate fare gates each station has, and ii) how much space there is for sampling."},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"png","fig-dpi":600,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.550","title":"Identifying promising MBTA stations for swab sampling: MBTA Ridership","subtitle":"How many passengers use different MBTA stations?","author":"Simon Grimm","date":"2024-07-25","categories":["MBTA","Swab sampling"],"draft":true,"jupyter":"venv","cap-location":"bottom"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
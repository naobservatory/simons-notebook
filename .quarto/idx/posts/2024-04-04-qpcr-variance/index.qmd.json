{"title":"qPCR variance","markdown":{"yaml":{"title":"qPCR variance","subtitle":"How much variance is introduced by varying qPCR protocols across different dimensions?","author":"Simon Grimm","date":"2024-04-04","toc":true,"format":{"html":{"code-fold":true,"code-tools":true,"code-link":true,"df-print":"paged"}},"jupyter":"venv","execute":{"freeze":"auto"},"cap-location":"bottom"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nThis is research based on the \"[Pooled swab sampling for pathogen early detection](https://naobservatory.org/blog/investigating-the-sensitivity-of-pooled-swab-sampling-for-pathogen-early-detection)\" project.\n\nIn our swab sampling research we want to compare qPCR results across different studies. Doing this requires a better understand how much variance is introduced by differing qPCR protocols. In the study [Assessing the comparability of cycle threshold values derived from five external quality assessment rounds for omicron nucleic acid testing](https://virologyj.biomedcentral.com/articles/10.1186/s12985-023-02032-z) researchers compared the qPCR results across many different laboratories who all used different combinations of qPCR machines, qPCR kits, and nucleic extraction methods. We can use this data to get an initial idea of how differing qPCR results might differ from one another.\n\n```{python}\n#| label: load-packages\n#| include: false\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n```\n\n# Differing qPCR kits\n\n\n## Plotting qPCR results for different qPCR kits\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s1-qpcr-kits-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'PCR instrument']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, extraction_kit, pcr_instrument in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['PCR instrument'] == pcr_instrument)]\n    qpcr_kits = sub_table['RT-PCR kit'].unique().tolist()\n    n_qpcr_kits = len(qpcr_kits)\n    x_increment = 0.7 / n_qpcr_kits\n    x_offset = -0.45\n    for qpcr_kit in qpcr_kits:\n        x_offset += x_increment\n        y_means = sub_table[sub_table['RT-PCR kit'] == qpcr_kit][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_labs_values = sub_table[sub_table['RT-PCR kit'] == qpcr_kit][[\"n_labs_2_e3\", \"n_labs_1_e3\", \"n_labs_5_e2\", \"n_labs_2_e2\"]].values.flatten()\n        min_n_labs = min(n_labs_values)\n        max_n_labs = max(n_labs_values)\n        if min_n_labs == max_n_labs:\n            n_labs_label = f\"n = {min_n_labs}\"\n        else:\n            n_labs_label = f\"n = {min_n_labs} - {max_n_labs}\"\n\n        y_sds = sub_table[sub_table['RT-PCR kit'] == qpcr_kit][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{qpcr_kit}\\n({n_labs_label})\", fmt='o', linestyle='None')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"qPCR kit\")\n\n    ax.set_ylim(Y_MIN, Y_MAX)\n    ax.set_xticks(range(len(y_means)))\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, extraction_kit, pcr_instrument = qpcr_target.strip(), extraction_kit.strip(), pcr_instrument.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, Extraction kit: {extraction_kit}, PCR instrument: {pcr_instrument}\")\n    # drop top and right spine\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n\n\n\n```\n\n## Plotting aggregate distribution of samples where only the qPCR kit differed\n\nIt is hard to discern how much variance there is between all the different kits, even within one concentration level. Something we can do to help make the variance more visible is to i) look only at examples where the qPCR kit differed, ii) take the means and standard deviations of the samples from each qPCR kit at a given concentration level, and iii) sample each qPCR kit's distribution, weighed by the number of labs using that kit.[^1]\n\n[^1]: This might well be wrong: A standard deviation already contains information on the number of underlying samples.\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s1-qpcr-kits-claude.tsv\", sep=\"\\t\")\n\ndata.columns = [col.strip() for col in data.columns]\n\nabsolute_sample_size = 3000\nXMIN, XMAX = (-10, 10)\n\n# only keep rows where neither extraction kit orPqCR instrumet are == \"various\"\ndata = data[~data['extraction kit'].str.contains(\"various\")]\ndata = data[~data['PCR instrument'].str.contains(\"various\")].reset_index()\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'PCR instrument']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\n\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 5), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, extraction_kit, pcr_instrument) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['PCR instrument'] == pcr_instrument)]\n\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = sub_table[f\"n_labs_{concentration}\"].values.tolist()\n        total_labs = sum(n_labs)\n        sample_per_lab = absolute_sample_size // total_labs\n\n        samples = np.hstack([np.random.normal(m, sd, sample_per_lab * n) for m, sd, n in zip(means, sds, n_labs)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {total_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    for x in np.arange(XMIN, XMAX, 2.5):\n\n        axs[i].axvline(x, color='gray', alpha=0.1, zorder=-1)\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, Extraction kit: {extraction_kit.strip()}, PCR instrument: {pcr_instrument.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n# Differing NA Extraction kits\n\n## Plotting qPCR results for different NA extraction kits\n```{python}\n#| warning: false\ndata = pd.read_csv(\"data/s2-na-kits-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\n# Extract unique combinations of qPCR target, Extraction kit, and PCR instrument\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'PCR instrument']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, qpcr_kit, pcr_instrument in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['PCR instrument'] == pcr_instrument)]\n    extraction_kits = sub_table['extraction kit'].unique().tolist()\n    n_extraction_kits = len(extraction_kits)\n    x_increment = 0.7 / n_extraction_kits\n\n    x_offset = -0.45\n\n\n    for extraction_kit in extraction_kits:\n        x_offset += x_increment\n        y_means = sub_table[sub_table['extraction kit'] == extraction_kit][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_labs_values = sub_table[sub_table['extraction kit'] == extraction_kit][[\"n_labs_2_e3\", \"n_labs_1_e3\", \"n_labs_5_e2\", \"n_labs_2_e2\"]].values.flatten()\n        min_n_labs = min(n_labs_values)\n        max_n_labs = max(n_labs_values)\n        if min_n_labs == max_n_labs:\n            n_labs_label = f\"n = {min_n_labs}\"\n        else:\n            n_labs_label = f\"n = {min_n_labs} - {max_n_labs}\"\n\n        y_sds = sub_table[sub_table['extraction kit'] == extraction_kit][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{extraction_kit}\\n({n_labs_label})\", fmt='o')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"Extraction kit\")\n\n\n    ax.set_xticks(range(len(y_means)))\n    ax.set_ylim(Y_MIN, Y_MAX)\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, qpcr_kit, pcr_instrument = qpcr_target.strip(), qpcr_kit.strip(), pcr_instrument.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, qPCR kit: {qpcr_kit}, PCR instrument: {pcr_instrument}\")\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n\n```\n\n## Plotting aggregate distribution of samples where only the NA extraction kit differed\n\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s2-na-kits-claude.tsv\", sep=\"\\t\")\ndata.columns = [col.strip() for col in data.columns]\n\nabsolute_sample_size = 3000\nXMIN, XMAX = (-10, 10)\n\n# only keep rows where neither extraction kit orPqCR instrumet are == \"various\"\ndata = data[~data['extraction kit'].str.contains(\"various\")]\ndata = data[~data['PCR instrument'].str.contains(\"various\")].reset_index()\n\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'PCR instrument']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\n\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 2.5 * n_unique_combinations), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, qpcr_kit, pcr_instrument) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['PCR instrument'] == pcr_instrument)]\n\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = sub_table[f\"n_labs_{concentration}\"].values.tolist()\n        total_labs = sum(n_labs)\n        sample_per_lab = absolute_sample_size // total_labs\n\n        samples = np.hstack([np.random.normal(m, sd, sample_per_lab * n) for m, sd, n in zip(means, sds, n_labs)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {total_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, qPCR kit: {qpcr_kit.strip()}, PCR instrument: {pcr_instrument.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n# Differing PCR machines\n\n## Plotting qPCR results for different qPCR machines\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s3-qpcr-machines-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'RT-PCR kit']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, extraction_kit, qpcr_kit in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['RT-PCR kit'] == qpcr_kit)]\n    pcr_instruments = sub_table['PCR instrument'].unique().tolist()\n    n_pcr_instruments = len(pcr_instruments)\n    x_increment = 0.7 / n_pcr_instruments\n\n    x_offset = -0.45\n    for pcr_instrument in pcr_instruments:\n        x_offset += x_increment\n\n        y_means = sub_table[sub_table['PCR instrument'] == pcr_instrument][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_labs_values = sub_table[sub_table['PCR instrument'] == pcr_instrument][[\"n_labs_2_e3\", \"n_labs_1_e3\", \"n_labs_5_e2\", \"n_labs_2_e2\"]].values.flatten()\n        min_n_labs = min(n_labs_values)\n        max_n_labs = max(n_labs_values)\n        if min_n_labs == max_n_labs:\n            n_labs_label = f\"n = {min_n_labs}\"\n        else:\n            n_labs_label = f\"n = {min_n_labs} - {max_n_labs}\"\n\n        y_sds = sub_table[sub_table['PCR instrument'] == pcr_instrument][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{pcr_instrument}\\n({n_labs_label})\", fmt='o')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"PCR instrument\")\n\n    ax.set_ylim(Y_MIN, Y_MAX)\n    ax.set_xticks(range(len(y_means)))\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, extraction_kit, qpcr_kit = qpcr_target.strip(), extraction_kit.strip(), qpcr_kit.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, Extraction kit: {extraction_kit}, qPCR kit: {qpcr_kit}\")\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n```\n\n## Plotting aggregate distribution of samples where only the RT-PCR kit differed\n\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s3-qpcr-machines-claude.tsv\", sep=\"\\t\")\ndata.columns = [col.strip() for col in data.columns]\n\nabsolute_sample_size = 3000\nXMIN, XMAX = (-10, 10)\n\n# only keep rows where neither extraction kit orPqCR instrumet are == \"various\"\ndata = data[~data['extraction kit'].str.contains(\"various\")]\ndata = data[~data['PCR instrument'].str.contains(\"various\")].reset_index()\n\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'extraction kit']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\n\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 2.5 * n_unique_combinations), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, qpcr_kit, extraction_kit) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['extraction kit'] == extraction_kit)]\n\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = sub_table[f\"n_labs_{concentration}\"].values.tolist()\n        total_labs = sum(n_labs)\n        sample_per_lab = absolute_sample_size // total_labs\n\n        samples = np.hstack([np.random.normal(m, sd, sample_per_lab * n) for m, sd, n in zip(means, sds, n_labs)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {total_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, qPCR kit: {qpcr_kit.strip()}, Extraction kit: {extraction_kit.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n\n\n## Plotting qPCR results for different labs who all use the same protocol\n\n```{python}\n#| warning: false\n\n# Load the new dataset\ndata = pd.read_csv(\"data/s4-individual-labs-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'RT-PCR kit', 'PCR instrument']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, extraction_kit, qpcr_kit, pcr_instrument in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['RT-PCR kit'] == qpcr_kit) & (data['PCR instrument'] == pcr_instrument)]\n    lab_codes = sub_table['lab_code'].unique().tolist()  # Use lab_code\n    n_lab_codes = len(lab_codes)  # Use n_lab_codes\n    x_increment = 0.7 / n_lab_codes\n\n    x_offset = -0.45\n    for lab_code in lab_codes:  # Iterate over lab_code\n\n        y_means = sub_table[sub_table['lab_code'] == lab_code][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_samples_values = sub_table[sub_table['lab_code'] == lab_code][[\"n_samples_2_e3\", \"n_samples_1_e3\", \"n_samples_5_e2\", \"n_samples_2_e2\"]].values.flatten()\n\n\n        y_sds = sub_table[sub_table['lab_code'] == lab_code][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_offset += x_increment\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{lab_code}\", fmt='o')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"Lab Code\")\n\n    ax.set_ylim(Y_MIN, Y_MAX)\n    ax.set_xticks(range(len(y_means)))\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, extraction_kit, qpcr_kit = qpcr_target.strip(), extraction_kit.strip(), qpcr_kit.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, Extraction kit: {extraction_kit}, qPCR kit: {qpcr_kit}, PCR instrument: {pcr_instrument}\")\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n\n```\n\n\n## Plotting aggregate distribution of samples where labs differed\n\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s4-individual-labs-claude.tsv\", sep=\"\\t\")\ndata.columns = [col.strip() for col in data.columns]\n\nsamples_per_lab = 300\nXMIN, XMAX = (-10, 10)\n\n\n\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'extraction kit', 'PCR instrument']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 2.5 * n_unique_combinations), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, qpcr_kit, extraction_kit, pcr_instrument) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['extraction kit'] == extraction_kit) & (data['PCR instrument'] == pcr_instrument)]\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = len(means)\n\n\n        samples = np.hstack([np.random.normal(m, sd, samples_per_lab) for m, sd in zip(means, sds)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {n_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, qPCR kit: {qpcr_kit.strip()}, Extraction kit: {extraction_kit.strip()}, PCR instrument: {pcr_instrument.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n","srcMarkdownNoYaml":"\n# Introduction\n\nThis is research based on the \"[Pooled swab sampling for pathogen early detection](https://naobservatory.org/blog/investigating-the-sensitivity-of-pooled-swab-sampling-for-pathogen-early-detection)\" project.\n\nIn our swab sampling research we want to compare qPCR results across different studies. Doing this requires a better understand how much variance is introduced by differing qPCR protocols. In the study [Assessing the comparability of cycle threshold values derived from five external quality assessment rounds for omicron nucleic acid testing](https://virologyj.biomedcentral.com/articles/10.1186/s12985-023-02032-z) researchers compared the qPCR results across many different laboratories who all used different combinations of qPCR machines, qPCR kits, and nucleic extraction methods. We can use this data to get an initial idea of how differing qPCR results might differ from one another.\n\n```{python}\n#| label: load-packages\n#| include: false\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n```\n\n# Differing qPCR kits\n\n\n## Plotting qPCR results for different qPCR kits\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s1-qpcr-kits-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'PCR instrument']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, extraction_kit, pcr_instrument in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['PCR instrument'] == pcr_instrument)]\n    qpcr_kits = sub_table['RT-PCR kit'].unique().tolist()\n    n_qpcr_kits = len(qpcr_kits)\n    x_increment = 0.7 / n_qpcr_kits\n    x_offset = -0.45\n    for qpcr_kit in qpcr_kits:\n        x_offset += x_increment\n        y_means = sub_table[sub_table['RT-PCR kit'] == qpcr_kit][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_labs_values = sub_table[sub_table['RT-PCR kit'] == qpcr_kit][[\"n_labs_2_e3\", \"n_labs_1_e3\", \"n_labs_5_e2\", \"n_labs_2_e2\"]].values.flatten()\n        min_n_labs = min(n_labs_values)\n        max_n_labs = max(n_labs_values)\n        if min_n_labs == max_n_labs:\n            n_labs_label = f\"n = {min_n_labs}\"\n        else:\n            n_labs_label = f\"n = {min_n_labs} - {max_n_labs}\"\n\n        y_sds = sub_table[sub_table['RT-PCR kit'] == qpcr_kit][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{qpcr_kit}\\n({n_labs_label})\", fmt='o', linestyle='None')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"qPCR kit\")\n\n    ax.set_ylim(Y_MIN, Y_MAX)\n    ax.set_xticks(range(len(y_means)))\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, extraction_kit, pcr_instrument = qpcr_target.strip(), extraction_kit.strip(), pcr_instrument.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, Extraction kit: {extraction_kit}, PCR instrument: {pcr_instrument}\")\n    # drop top and right spine\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n\n\n\n```\n\n## Plotting aggregate distribution of samples where only the qPCR kit differed\n\nIt is hard to discern how much variance there is between all the different kits, even within one concentration level. Something we can do to help make the variance more visible is to i) look only at examples where the qPCR kit differed, ii) take the means and standard deviations of the samples from each qPCR kit at a given concentration level, and iii) sample each qPCR kit's distribution, weighed by the number of labs using that kit.[^1]\n\n[^1]: This might well be wrong: A standard deviation already contains information on the number of underlying samples.\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s1-qpcr-kits-claude.tsv\", sep=\"\\t\")\n\ndata.columns = [col.strip() for col in data.columns]\n\nabsolute_sample_size = 3000\nXMIN, XMAX = (-10, 10)\n\n# only keep rows where neither extraction kit orPqCR instrumet are == \"various\"\ndata = data[~data['extraction kit'].str.contains(\"various\")]\ndata = data[~data['PCR instrument'].str.contains(\"various\")].reset_index()\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'PCR instrument']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\n\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 5), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, extraction_kit, pcr_instrument) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['PCR instrument'] == pcr_instrument)]\n\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = sub_table[f\"n_labs_{concentration}\"].values.tolist()\n        total_labs = sum(n_labs)\n        sample_per_lab = absolute_sample_size // total_labs\n\n        samples = np.hstack([np.random.normal(m, sd, sample_per_lab * n) for m, sd, n in zip(means, sds, n_labs)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {total_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    for x in np.arange(XMIN, XMAX, 2.5):\n\n        axs[i].axvline(x, color='gray', alpha=0.1, zorder=-1)\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, Extraction kit: {extraction_kit.strip()}, PCR instrument: {pcr_instrument.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n# Differing NA Extraction kits\n\n## Plotting qPCR results for different NA extraction kits\n```{python}\n#| warning: false\ndata = pd.read_csv(\"data/s2-na-kits-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\n# Extract unique combinations of qPCR target, Extraction kit, and PCR instrument\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'PCR instrument']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, qpcr_kit, pcr_instrument in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['PCR instrument'] == pcr_instrument)]\n    extraction_kits = sub_table['extraction kit'].unique().tolist()\n    n_extraction_kits = len(extraction_kits)\n    x_increment = 0.7 / n_extraction_kits\n\n    x_offset = -0.45\n\n\n    for extraction_kit in extraction_kits:\n        x_offset += x_increment\n        y_means = sub_table[sub_table['extraction kit'] == extraction_kit][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_labs_values = sub_table[sub_table['extraction kit'] == extraction_kit][[\"n_labs_2_e3\", \"n_labs_1_e3\", \"n_labs_5_e2\", \"n_labs_2_e2\"]].values.flatten()\n        min_n_labs = min(n_labs_values)\n        max_n_labs = max(n_labs_values)\n        if min_n_labs == max_n_labs:\n            n_labs_label = f\"n = {min_n_labs}\"\n        else:\n            n_labs_label = f\"n = {min_n_labs} - {max_n_labs}\"\n\n        y_sds = sub_table[sub_table['extraction kit'] == extraction_kit][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{extraction_kit}\\n({n_labs_label})\", fmt='o')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"Extraction kit\")\n\n\n    ax.set_xticks(range(len(y_means)))\n    ax.set_ylim(Y_MIN, Y_MAX)\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, qpcr_kit, pcr_instrument = qpcr_target.strip(), qpcr_kit.strip(), pcr_instrument.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, qPCR kit: {qpcr_kit}, PCR instrument: {pcr_instrument}\")\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n\n```\n\n## Plotting aggregate distribution of samples where only the NA extraction kit differed\n\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s2-na-kits-claude.tsv\", sep=\"\\t\")\ndata.columns = [col.strip() for col in data.columns]\n\nabsolute_sample_size = 3000\nXMIN, XMAX = (-10, 10)\n\n# only keep rows where neither extraction kit orPqCR instrumet are == \"various\"\ndata = data[~data['extraction kit'].str.contains(\"various\")]\ndata = data[~data['PCR instrument'].str.contains(\"various\")].reset_index()\n\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'PCR instrument']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\n\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 2.5 * n_unique_combinations), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, qpcr_kit, pcr_instrument) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['PCR instrument'] == pcr_instrument)]\n\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = sub_table[f\"n_labs_{concentration}\"].values.tolist()\n        total_labs = sum(n_labs)\n        sample_per_lab = absolute_sample_size // total_labs\n\n        samples = np.hstack([np.random.normal(m, sd, sample_per_lab * n) for m, sd, n in zip(means, sds, n_labs)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {total_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, qPCR kit: {qpcr_kit.strip()}, PCR instrument: {pcr_instrument.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n# Differing PCR machines\n\n## Plotting qPCR results for different qPCR machines\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s3-qpcr-machines-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'RT-PCR kit']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, extraction_kit, qpcr_kit in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['RT-PCR kit'] == qpcr_kit)]\n    pcr_instruments = sub_table['PCR instrument'].unique().tolist()\n    n_pcr_instruments = len(pcr_instruments)\n    x_increment = 0.7 / n_pcr_instruments\n\n    x_offset = -0.45\n    for pcr_instrument in pcr_instruments:\n        x_offset += x_increment\n\n        y_means = sub_table[sub_table['PCR instrument'] == pcr_instrument][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_labs_values = sub_table[sub_table['PCR instrument'] == pcr_instrument][[\"n_labs_2_e3\", \"n_labs_1_e3\", \"n_labs_5_e2\", \"n_labs_2_e2\"]].values.flatten()\n        min_n_labs = min(n_labs_values)\n        max_n_labs = max(n_labs_values)\n        if min_n_labs == max_n_labs:\n            n_labs_label = f\"n = {min_n_labs}\"\n        else:\n            n_labs_label = f\"n = {min_n_labs} - {max_n_labs}\"\n\n        y_sds = sub_table[sub_table['PCR instrument'] == pcr_instrument][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{pcr_instrument}\\n({n_labs_label})\", fmt='o')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"PCR instrument\")\n\n    ax.set_ylim(Y_MIN, Y_MAX)\n    ax.set_xticks(range(len(y_means)))\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, extraction_kit, qpcr_kit = qpcr_target.strip(), extraction_kit.strip(), qpcr_kit.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, Extraction kit: {extraction_kit}, qPCR kit: {qpcr_kit}\")\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n```\n\n## Plotting aggregate distribution of samples where only the RT-PCR kit differed\n\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s3-qpcr-machines-claude.tsv\", sep=\"\\t\")\ndata.columns = [col.strip() for col in data.columns]\n\nabsolute_sample_size = 3000\nXMIN, XMAX = (-10, 10)\n\n# only keep rows where neither extraction kit orPqCR instrumet are == \"various\"\ndata = data[~data['extraction kit'].str.contains(\"various\")]\ndata = data[~data['PCR instrument'].str.contains(\"various\")].reset_index()\n\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'extraction kit']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\n\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 2.5 * n_unique_combinations), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, qpcr_kit, extraction_kit) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['extraction kit'] == extraction_kit)]\n\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = sub_table[f\"n_labs_{concentration}\"].values.tolist()\n        total_labs = sum(n_labs)\n        sample_per_lab = absolute_sample_size // total_labs\n\n        samples = np.hstack([np.random.normal(m, sd, sample_per_lab * n) for m, sd, n in zip(means, sds, n_labs)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {total_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, qPCR kit: {qpcr_kit.strip()}, Extraction kit: {extraction_kit.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n\n\n## Plotting qPCR results for different labs who all use the same protocol\n\n```{python}\n#| warning: false\n\n# Load the new dataset\ndata = pd.read_csv(\"data/s4-individual-labs-claude.tsv\", sep=\"\\t\")\ndata = data.apply(lambda x: x.str.strip() if x.dtype == \"string\" else x)\ndata.columns = [col.strip() for col in data.columns]\n\nY_MIN, Y_MAX = (28,40)\n\n\nunique_combinations = data[['qPCR target', 'extraction kit', 'RT-PCR kit', 'PCR instrument']].drop_duplicates().values.tolist()\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\ntable_iterator = -1\nfor qpcr_target, extraction_kit, qpcr_kit, pcr_instrument in unique_combinations:\n    fig, ax = plt.subplots(figsize=(9, 5))\n    table_iterator += 1\n\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['extraction kit'] == extraction_kit) & (data['RT-PCR kit'] == qpcr_kit) & (data['PCR instrument'] == pcr_instrument)]\n    lab_codes = sub_table['lab_code'].unique().tolist()  # Use lab_code\n    n_lab_codes = len(lab_codes)  # Use n_lab_codes\n    x_increment = 0.7 / n_lab_codes\n\n    x_offset = -0.45\n    for lab_code in lab_codes:  # Iterate over lab_code\n\n        y_means = sub_table[sub_table['lab_code'] == lab_code][[\"mean_2_e3\", \"mean_1_e3\", \"mean_5_e2\", \"mean_2_e2\"]].values.flatten()\n        n_samples_values = sub_table[sub_table['lab_code'] == lab_code][[\"n_samples_2_e3\", \"n_samples_1_e3\", \"n_samples_5_e2\", \"n_samples_2_e2\"]].values.flatten()\n\n\n        y_sds = sub_table[sub_table['lab_code'] == lab_code][[\"sd_2_e3\", \"sd_1_e3\", \"sd_5_e2\", \"sd_2_e2\"]].values.flatten()\n        x_offset += x_increment\n        x_values = [x + x_offset for x in range(len(y_means))]\n        ax.errorbar(x_values, y_means, y_sds, alpha=0.5, label=f\"{lab_code}\", fmt='o')\n        ax.legend(loc='upper center', bbox_to_anchor=(0.5, -0.05), frameon=False, ncol=4, title=\"Lab Code\")\n\n    ax.set_ylim(Y_MIN, Y_MAX)\n    ax.set_xticks(range(len(y_means)))\n    for x in range(Y_MIN, Y_MAX, 2):\n        ax.axhline(x, color='gray', alpha=0.1)\n    x_labels = []\n    for concentration in concentrations_per_ml:\n        tidy_concentration  = concentration.replace(\"_\", \" \").replace(\"e\", \"E\")\n        label = f\"{tidy_concentration} gc / ml\"\n        x_labels.append(label)\n    ax.set_xticklabels(x_labels)\n    qpcr_target, extraction_kit, qpcr_kit = qpcr_target.strip(), extraction_kit.strip(), qpcr_kit.strip()\n    plt.title(f\"qPCR target: {qpcr_target}, Extraction kit: {extraction_kit}, qPCR kit: {qpcr_kit}, PCR instrument: {pcr_instrument}\")\n    ax.spines['top'].set_color('none')\n    ax.spines['right'].set_color('none')\n\n\n```\n\n\n## Plotting aggregate distribution of samples where labs differed\n\n\n```{python}\n#| warning: false\n\ndata = pd.read_csv(\"data/s4-individual-labs-claude.tsv\", sep=\"\\t\")\ndata.columns = [col.strip() for col in data.columns]\n\nsamples_per_lab = 300\nXMIN, XMAX = (-10, 10)\n\n\n\nunique_combinations = data[['qPCR target', 'RT-PCR kit', 'extraction kit', 'PCR instrument']].drop_duplicates().values.tolist()\n\nn_unique_combinations = len(unique_combinations)\nfig, axs = plt.subplots(n_unique_combinations, figsize=(9, 2.5 * n_unique_combinations), sharex=True)\n\nconcentrations_per_ml = [\"2_e3\", \"1_e3\", \"5_e2\", \"2_e2\"]\n\nfor i, (qpcr_target, qpcr_kit, extraction_kit, pcr_instrument) in enumerate(unique_combinations):\n    sub_table = data[(data['qPCR target'] == qpcr_target) & (data['RT-PCR kit'] == qpcr_kit) & (data['extraction kit'] == extraction_kit) & (data['PCR instrument'] == pcr_instrument)]\n    distributions = []\n    y_axis_labels = []\n\n\n    for concentration in concentrations_per_ml:\n        means = sub_table[f\"mean_{concentration}\"].values.tolist()\n        sds = sub_table[f\"sd_{concentration}\"].values.tolist()\n        n_labs = len(means)\n\n\n        samples = np.hstack([np.random.normal(m, sd, samples_per_lab) for m, sd in zip(means, sds)])\n        mean = np.mean(samples)\n        distribution_around_zero = samples - mean\n        distributions.append(distribution_around_zero)\n        y_axis_labels.append(concentration + \"\\n\" + f\"n = {n_labs}\")\n\n\n\n    sns.violinplot(data=distributions, ax=axs[i], orient='h')\n    axs[i].set_yticks(range(len(concentrations_per_ml)))\n    axs[i].set_yticklabels(y_axis_labels)\n    axs[i].set_title(f\"qPCR target: {qpcr_target.strip()}, qPCR kit: {qpcr_kit.strip()}, Extraction kit: {extraction_kit.strip()}, PCR instrument: {pcr_instrument.strip()}\")\n    axs[i].set_xlim(XMIN, XMAX)\n    axs[i].spines['top'].set_color('none')\n    axs[i].spines['right'].set_color('none')\nplt.show()\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.4.550","title":"qPCR variance","subtitle":"How much variance is introduced by varying qPCR protocols across different dimensions?","author":"Simon Grimm","date":"2024-04-04","jupyter":"venv","cap-location":"bottom"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}
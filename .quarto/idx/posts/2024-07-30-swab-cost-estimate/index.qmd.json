{"title":"Costing out a Pooled Swab Sampling Program.","markdown":{"yaml":{"title":"Costing out a Pooled Swab Sampling Program.","subtitle":"How much would it cost to build and run a pooled swab sampling program?","author":"Simon Grimm","date":"2024-07-30","categories":["Swab sampling","Modeling"],"toc":true,"draft":true,"format":{"html":{"code-fold":true,"code-tools":true,"code-link":true,"df-print":"paged","fig-format":"png","fig-dpi":600}},"jupyter":"venv","cap-location":"bottom"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n```{python}\n#| echo: false\n#| results: hide\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport math\nimport random\nfrom typing import Dict\nimport locale\nfrom scipy import stats\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom typing import Optional, List\nfrom dataclasses import field\n\n```\n\n\n\n\n\n```{python}\nswab_ras = pd.read_csv(\"data/adjusted_composite_ras.tsv\", sep=\"\\t\")[\"relative_abundance\"].tolist()\nEPSILON = 0.000001\n\n\n@dataclass(kw_only=True, eq=True)\nclass PathogenProperties:\n    name: str = \"Sars_CoV-2\"\n    doubling_time: int = 3\n    cv_doubling_time: float = 10.0\n    genome_length: int = 30000\n\n\n@dataclass(kw_only=True, eq=True)\nclass SamplingParameters:\n    \"\"\"Parameters for sampling in pathogen detection\"\"\"\n    shedding_values: List[float] = field(default_factory=lambda: swab_ras)\n    sigma_shedding_values: float = 0.05\n    shedding_duration: int = 7\n    sigma_shedding_duration: float = 0.05\n    sample_population: int = 100\n    sample_cost: float = 200\n    low_quality: bool = False\n    direct_flaggable: bool = False\n\n@dataclass(kw_only=True, eq=True)\nclass SequencingParameters:\n    read_length: int = 10000\n    sample_depth: int = int(8e5)\n    run_cost: float = 450\n    processing_delay: int = 4\n\n@dataclass(kw_only=True, eq=True)\nclass SamplingSequencingSchedule:\n    # Sampling and sequencing schedules (True for active days)\n    sampling_m: bool = True\n    sampling_t: bool = True\n    sampling_w: bool = True\n    sampling_r: bool = True\n    sampling_f: bool = True\n    sampling_s: bool = False\n    sampling_u: bool = False\n    sequencing_m: bool = True\n    sequencing_t: bool = True\n    sequencing_w: bool = True\n    sequencing_r: bool = True\n    sequencing_f: bool = True\n    sequencing_s: bool = False\n    sequencing_u: bool = False\n\n@dataclass(kw_only=True, eq=True)\nclass GlobalSettings:\n    min_observations: int = 2\n    sites: int = 1\n    population_size: int = 1000000\n    overhead: float = 50.0\n\nnumber_of_simulations = 1000\n\n\n@dataclass(kw_only=True, eq=True)\nclass Inputs:\n    pathogen_props: PathogenProperties\n    sampling_params: SamplingParameters\n    sequencing_params: SequencingParameters\n    schedule: SamplingSequencingSchedule\n    global_settings: GlobalSettings\n    number_of_simulations: int = 1000\n\n    @classmethod\n    def create_default(cls):\n        return cls(\n            pathogen_props=PathogenProperties(),\n            sampling_params=SamplingParameters(),\n            sequencing_params=SequencingParameters(),\n            schedule=SamplingSequencingSchedule(),\n            global_settings=GlobalSettings()\n        )\n\n```\n\n\n\n\n\n```{python}\n\ndef get_input_cv(input_value, input_cv):\n    mean = float(input_value)\n    cv = float(input_cv) / 100\n\n    if cv < EPSILON:\n        return mean\n\n    stdev = cv * mean\n    return random.normalvariate(mean, stdev)\n\n\ndef get_input_sigma(input_value, input_sigma):\n    geom_mean = float(input_value)\n    sigma = float(input_sigma)\n\n    if sigma < EPSILON:\n        return geom_mean\n\n    return math.exp(random.normalvariate(math.log(geom_mean), sigma))\n\n\ndef get_inputs_biased(input_values, input_sigma):\n    empirical_values = [float(x) for x in input_values]\n    sigma = float(input_sigma)\n    if sigma < EPSILON:\n        return empirical_values\n\n    bias = math.exp(random.normalvariate(0, sigma))\n\n    return [empirical_value * bias for empirical_value in empirical_values]\n\n\ndef simulate_one(\n    inputs: Inputs\n):\n    pathogen_props = inputs.pathogen_props\n    sampling_params = inputs.sampling_params\n    sequencing_params = inputs.sequencing_params\n    schedule = inputs.schedule\n    global_settings = inputs.global_settings\n    number_of_simulations = inputs.number_of_simulations\n\n\n\n    day = 0\n    population = global_settings.population_size\n    r = math.log(2) / get_input_cv(\n        pathogen_props.doubling_time, pathogen_props.cv_doubling_time\n    )\n    growth_factor = math.exp(r)\n    cumulative_incidence = 1 / population\n\n    detectable_days = get_input_sigma(\n        sampling_params.shedding_duration, sampling_params.sigma_shedding_duration\n    )\n    ra_sicks = get_inputs_biased(\n        sampling_params.shedding_values, sampling_params.sigma_shedding_values\n    )\n\n    n_min_observations = int(global_settings.min_observations)\n    observations = 0\n\n    n_sites = int(global_settings.sites)\n    site_infos = [\n        {\n            \"sample_sick\": 0,\n            \"sample_total\": 0,\n            \"day_offset\": random.randint(0, 6),\n        }\n        for _ in range(n_sites)\n    ]\n\n    bp_genome_length = int(pathogen_props.genome_length)\n    n_sample_population = int(sampling_params.sample_population)\n    read_length_usable = min(int(sequencing_params.read_length), bp_genome_length)\n\n    if sampling_params.low_quality:\n        read_length_usable = min(read_length_usable, 120)\n\n    fraction_useful_reads = read_length_usable / bp_genome_length\n\n    if sampling_params.direct_flaggable:\n        fraction_useful_reads = 1\n\n    v_processing_delay_factor = growth_factor ** float(\n        sequencing_params.processing_delay\n    )\n    n_reads = int(sequencing_params.sample_depth)\n\n    should_sample = [getattr(schedule, f'sampling_{day}') for day in \"mtwrfsu\"]\n    should_sequence = [getattr(schedule, f'sequencing_{day}') for day in \"mtwrfsu\"]\n\n    while True:\n        day += 1\n        cumulative_incidence *= growth_factor\n\n        for site in range(n_sites):\n            day_of_week = (day + site_infos[site][\"day_offset\"]) % 7\n            if should_sample[day_of_week]:\n                daily_incidence = cumulative_incidence * r\n                individual_probability_sick = sum(\n                    daily_incidence / (growth_factor**i)\n                    for i in range(int(detectable_days))\n                )\n                n_sick = stats.poisson.rvs(\n                    n_sample_population * individual_probability_sick\n                )\n                site_infos[site][\"sample_sick\"] += n_sick\n                site_infos[site][\"sample_total\"] += n_sample_population\n\n            if should_sequence[day_of_week]:\n                ra_sick = 0\n                if site_infos[site][\"sample_sick\"] == 0:\n                    ra_sick = 0\n                elif len(ra_sicks) == 1:\n                    ra_sick = ra_sicks[0]\n                elif site_infos[site][\"sample_sick\"] > len(ra_sicks) * 3:\n                    ra_sick = sum(ra_sicks) / len(ra_sicks)\n                else:\n                    ra_sick = sum(\n                        random.choice(ra_sicks)\n                        for _ in range(site_infos[site][\"sample_sick\"])\n                    )\n                    ra_sick /= site_infos[site][\"sample_sick\"]\n\n                probability_read_is_useful = (\n                    site_infos[site][\"sample_sick\"]\n                    / site_infos[site][\"sample_total\"]\n                    * ra_sick\n                    * fraction_useful_reads\n                )\n\n                site_infos[site][\"sample_sick\"] = 0\n                site_infos[site][\"sample_total\"] = 0\n\n                if probability_read_is_useful > 0:\n                    observations += stats.poisson.rvs(\n                        n_reads * probability_read_is_useful\n                    )\n                    if observations >= n_min_observations:\n                        # Convert cumulative incidence to percentage\n                        cumulative_incidence_percentage = cumulative_incidence * 100\n                        return cumulative_incidence * v_processing_delay_factor\n\n        if cumulative_incidence > 1 or day > 365 * 10:\n            return 1\n\n\ndef calculate_cost(inputs: Inputs):\n    sampling_params = inputs.sampling_params\n    sequencing_params = inputs.sequencing_params\n    schedule = inputs.schedule\n    global_settings = inputs.global_settings\n    locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n\n    # Calculate number of weekly samples and sequences\n    n_samples_weekly = sum(getattr(schedule, f'sampling_{day}') for day in \"mtwrfsu\")\n    n_sequences_weekly = sum(getattr(schedule, f'sequencing_{day}') for day in \"mtwrfsu\")\n\n    # Calculate total cost\n    total_cost = (\n        global_settings.sites *\n        (1 + (global_settings.overhead / 100)) *\n        52 *\n        (n_samples_weekly * sampling_params.sample_cost +\n         n_sequences_weekly * sequencing_params.run_cost)\n    )\n\n    # Return formatted csot\n    formatted_cost = locale.currency(total_cost, grouping=True)\n    return formatted_cost\n\n\ndef simulate_many(inputs: Inputs, n_simulations: int):\n    results = []\n    for _ in range(n_simulations):\n        results.append(simulate_one(inputs))\n    return results\n\n\ndef plot_simulation(results: List[float], label: str):\n    index = np.arange(len(results))/10\n    cumulative_incidence = sorted(results)\n    median = np.median(cumulative_incidence)\n    plt.plot(index, cumulative_incidence, label=label)\n\ndef run_simulation(inputs: Inputs):\n    costs = calculate_cost(inputs)\n    n_simulations = 1000\n    doubling_time = inputs.pathogen_props.doubling_time\n    sample_size = inputs.sampling_params.sample_population\n    sites = inputs.global_settings.sites\n    label = f\"Doubling time: {doubling_time}, Sample size: {sample_size}, Sites: {sites}, Annual Cost: {costs}\"\n    results = simulate_many(inputs, n_simulations)\n    plot_simulation(results, label)\n    median = np.median(results)\n    print(f\"Doubling time: {doubling_time}, Sample size: {sample_size}, Sites: {sites}\")\n    print(f\"Cost: {costs}, Median cumulative incidence: {median}\")\n```\n\n\n```{python}\n\nplt.figure(figsize=(10, 6), dpi=600)\nplt.xlabel(\"%\")\nplt.ylabel(\"Cumulative Incidence\")\nplt.ylim(0, 0.08)\nplt.yticks(np.arange(0, 0.09, 0.01), [f'{x*100:.0f}%' for x in np.arange(0, 0.09, 0.01)])\nplt.title(f\"Cumulative Incidence across 1000 simulations\")\nplt.grid(True, linestyle=\"--\", alpha=0.7)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nsample_sizes = [\n    100, 200, 400\n]\n\nfor sample_size in sample_sizes:\n    cost_per_swab = 5\n    max_swabs_per_site = 50\n    within_city_sampling_sites = math.ceil(sample_size / max_swabs_per_site)\n    labor_cost_per_50_swabs = 4 * 2 * 30 # 4 hours, 2 people, $30/hour\n    sample_cost = within_city_sampling_sites * labor_cost_per_50_swabs + cost_per_swab * sample_size\n    inputs = Inputs.create_default()\n    inputs.sampling_params.sample_population = sample_size\n    inputs.sampling_params.sample_cost = sample_cost\n    run_simulation(inputs)\n\nplt.legend()\nplt.show()\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<!-- ```{python}\n#Unneeded stuff\n\n\n\n@dataclass\nclass SamplingSite:\n    name: str\n    cost_per_sample: Decimal\n    capital_cost: Decimal\n    num_samples: int\n    staff_cost: Decimal\n    staff_hours: Decimal\n    num_staff: int\n    city: str\n    area: Optional[float] = None\n\n    def daily_cost(self):\n        sample_costs = self.cost_per_sample * self.num_samples\n        staff_costs = self.staff_cost * self.staff_hours * self.num_staff\n        return sample_costs + staff_costs\n\n    def __repr__(self) -> str:\n        return (f\"SamplingSite(name='{self.name}', cost_per_sample={self.cost_per_sample}, \"\n                f\"num_samples={self.num_samples}, staff_cost={self.staff_cost}, \"\n                f\"staff_hours={self.staff_hours}, num_staff={self.num_staff}, \"\n                f\"city='{self.city}', area={self.area})\")\n\n\nclass PathogenProperties:\n    name: str\n    relative_abundance_distribution: List[float]\n    doubling_time: int\n    genome_length: int\n\nclass Sequencer:\n    name: str\n    cost_per_run: Decimal\n    capital_cost: Decimal\n    sequencing_depth: int\n    read_length: int\n    processing_delay: int\n\n``` -->","srcMarkdownNoYaml":"\n# Introduction\n\n```{python}\n#| echo: false\n#| results: hide\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport math\nimport random\nfrom typing import Dict\nimport locale\nfrom scipy import stats\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom typing import Optional, List\nfrom dataclasses import field\n\n```\n\n\n\n\n\n```{python}\nswab_ras = pd.read_csv(\"data/adjusted_composite_ras.tsv\", sep=\"\\t\")[\"relative_abundance\"].tolist()\nEPSILON = 0.000001\n\n\n@dataclass(kw_only=True, eq=True)\nclass PathogenProperties:\n    name: str = \"Sars_CoV-2\"\n    doubling_time: int = 3\n    cv_doubling_time: float = 10.0\n    genome_length: int = 30000\n\n\n@dataclass(kw_only=True, eq=True)\nclass SamplingParameters:\n    \"\"\"Parameters for sampling in pathogen detection\"\"\"\n    shedding_values: List[float] = field(default_factory=lambda: swab_ras)\n    sigma_shedding_values: float = 0.05\n    shedding_duration: int = 7\n    sigma_shedding_duration: float = 0.05\n    sample_population: int = 100\n    sample_cost: float = 200\n    low_quality: bool = False\n    direct_flaggable: bool = False\n\n@dataclass(kw_only=True, eq=True)\nclass SequencingParameters:\n    read_length: int = 10000\n    sample_depth: int = int(8e5)\n    run_cost: float = 450\n    processing_delay: int = 4\n\n@dataclass(kw_only=True, eq=True)\nclass SamplingSequencingSchedule:\n    # Sampling and sequencing schedules (True for active days)\n    sampling_m: bool = True\n    sampling_t: bool = True\n    sampling_w: bool = True\n    sampling_r: bool = True\n    sampling_f: bool = True\n    sampling_s: bool = False\n    sampling_u: bool = False\n    sequencing_m: bool = True\n    sequencing_t: bool = True\n    sequencing_w: bool = True\n    sequencing_r: bool = True\n    sequencing_f: bool = True\n    sequencing_s: bool = False\n    sequencing_u: bool = False\n\n@dataclass(kw_only=True, eq=True)\nclass GlobalSettings:\n    min_observations: int = 2\n    sites: int = 1\n    population_size: int = 1000000\n    overhead: float = 50.0\n\nnumber_of_simulations = 1000\n\n\n@dataclass(kw_only=True, eq=True)\nclass Inputs:\n    pathogen_props: PathogenProperties\n    sampling_params: SamplingParameters\n    sequencing_params: SequencingParameters\n    schedule: SamplingSequencingSchedule\n    global_settings: GlobalSettings\n    number_of_simulations: int = 1000\n\n    @classmethod\n    def create_default(cls):\n        return cls(\n            pathogen_props=PathogenProperties(),\n            sampling_params=SamplingParameters(),\n            sequencing_params=SequencingParameters(),\n            schedule=SamplingSequencingSchedule(),\n            global_settings=GlobalSettings()\n        )\n\n```\n\n\n\n\n\n```{python}\n\ndef get_input_cv(input_value, input_cv):\n    mean = float(input_value)\n    cv = float(input_cv) / 100\n\n    if cv < EPSILON:\n        return mean\n\n    stdev = cv * mean\n    return random.normalvariate(mean, stdev)\n\n\ndef get_input_sigma(input_value, input_sigma):\n    geom_mean = float(input_value)\n    sigma = float(input_sigma)\n\n    if sigma < EPSILON:\n        return geom_mean\n\n    return math.exp(random.normalvariate(math.log(geom_mean), sigma))\n\n\ndef get_inputs_biased(input_values, input_sigma):\n    empirical_values = [float(x) for x in input_values]\n    sigma = float(input_sigma)\n    if sigma < EPSILON:\n        return empirical_values\n\n    bias = math.exp(random.normalvariate(0, sigma))\n\n    return [empirical_value * bias for empirical_value in empirical_values]\n\n\ndef simulate_one(\n    inputs: Inputs\n):\n    pathogen_props = inputs.pathogen_props\n    sampling_params = inputs.sampling_params\n    sequencing_params = inputs.sequencing_params\n    schedule = inputs.schedule\n    global_settings = inputs.global_settings\n    number_of_simulations = inputs.number_of_simulations\n\n\n\n    day = 0\n    population = global_settings.population_size\n    r = math.log(2) / get_input_cv(\n        pathogen_props.doubling_time, pathogen_props.cv_doubling_time\n    )\n    growth_factor = math.exp(r)\n    cumulative_incidence = 1 / population\n\n    detectable_days = get_input_sigma(\n        sampling_params.shedding_duration, sampling_params.sigma_shedding_duration\n    )\n    ra_sicks = get_inputs_biased(\n        sampling_params.shedding_values, sampling_params.sigma_shedding_values\n    )\n\n    n_min_observations = int(global_settings.min_observations)\n    observations = 0\n\n    n_sites = int(global_settings.sites)\n    site_infos = [\n        {\n            \"sample_sick\": 0,\n            \"sample_total\": 0,\n            \"day_offset\": random.randint(0, 6),\n        }\n        for _ in range(n_sites)\n    ]\n\n    bp_genome_length = int(pathogen_props.genome_length)\n    n_sample_population = int(sampling_params.sample_population)\n    read_length_usable = min(int(sequencing_params.read_length), bp_genome_length)\n\n    if sampling_params.low_quality:\n        read_length_usable = min(read_length_usable, 120)\n\n    fraction_useful_reads = read_length_usable / bp_genome_length\n\n    if sampling_params.direct_flaggable:\n        fraction_useful_reads = 1\n\n    v_processing_delay_factor = growth_factor ** float(\n        sequencing_params.processing_delay\n    )\n    n_reads = int(sequencing_params.sample_depth)\n\n    should_sample = [getattr(schedule, f'sampling_{day}') for day in \"mtwrfsu\"]\n    should_sequence = [getattr(schedule, f'sequencing_{day}') for day in \"mtwrfsu\"]\n\n    while True:\n        day += 1\n        cumulative_incidence *= growth_factor\n\n        for site in range(n_sites):\n            day_of_week = (day + site_infos[site][\"day_offset\"]) % 7\n            if should_sample[day_of_week]:\n                daily_incidence = cumulative_incidence * r\n                individual_probability_sick = sum(\n                    daily_incidence / (growth_factor**i)\n                    for i in range(int(detectable_days))\n                )\n                n_sick = stats.poisson.rvs(\n                    n_sample_population * individual_probability_sick\n                )\n                site_infos[site][\"sample_sick\"] += n_sick\n                site_infos[site][\"sample_total\"] += n_sample_population\n\n            if should_sequence[day_of_week]:\n                ra_sick = 0\n                if site_infos[site][\"sample_sick\"] == 0:\n                    ra_sick = 0\n                elif len(ra_sicks) == 1:\n                    ra_sick = ra_sicks[0]\n                elif site_infos[site][\"sample_sick\"] > len(ra_sicks) * 3:\n                    ra_sick = sum(ra_sicks) / len(ra_sicks)\n                else:\n                    ra_sick = sum(\n                        random.choice(ra_sicks)\n                        for _ in range(site_infos[site][\"sample_sick\"])\n                    )\n                    ra_sick /= site_infos[site][\"sample_sick\"]\n\n                probability_read_is_useful = (\n                    site_infos[site][\"sample_sick\"]\n                    / site_infos[site][\"sample_total\"]\n                    * ra_sick\n                    * fraction_useful_reads\n                )\n\n                site_infos[site][\"sample_sick\"] = 0\n                site_infos[site][\"sample_total\"] = 0\n\n                if probability_read_is_useful > 0:\n                    observations += stats.poisson.rvs(\n                        n_reads * probability_read_is_useful\n                    )\n                    if observations >= n_min_observations:\n                        # Convert cumulative incidence to percentage\n                        cumulative_incidence_percentage = cumulative_incidence * 100\n                        return cumulative_incidence * v_processing_delay_factor\n\n        if cumulative_incidence > 1 or day > 365 * 10:\n            return 1\n\n\ndef calculate_cost(inputs: Inputs):\n    sampling_params = inputs.sampling_params\n    sequencing_params = inputs.sequencing_params\n    schedule = inputs.schedule\n    global_settings = inputs.global_settings\n    locale.setlocale(locale.LC_ALL, 'en_US.UTF-8')\n\n    # Calculate number of weekly samples and sequences\n    n_samples_weekly = sum(getattr(schedule, f'sampling_{day}') for day in \"mtwrfsu\")\n    n_sequences_weekly = sum(getattr(schedule, f'sequencing_{day}') for day in \"mtwrfsu\")\n\n    # Calculate total cost\n    total_cost = (\n        global_settings.sites *\n        (1 + (global_settings.overhead / 100)) *\n        52 *\n        (n_samples_weekly * sampling_params.sample_cost +\n         n_sequences_weekly * sequencing_params.run_cost)\n    )\n\n    # Return formatted csot\n    formatted_cost = locale.currency(total_cost, grouping=True)\n    return formatted_cost\n\n\ndef simulate_many(inputs: Inputs, n_simulations: int):\n    results = []\n    for _ in range(n_simulations):\n        results.append(simulate_one(inputs))\n    return results\n\n\ndef plot_simulation(results: List[float], label: str):\n    index = np.arange(len(results))/10\n    cumulative_incidence = sorted(results)\n    median = np.median(cumulative_incidence)\n    plt.plot(index, cumulative_incidence, label=label)\n\ndef run_simulation(inputs: Inputs):\n    costs = calculate_cost(inputs)\n    n_simulations = 1000\n    doubling_time = inputs.pathogen_props.doubling_time\n    sample_size = inputs.sampling_params.sample_population\n    sites = inputs.global_settings.sites\n    label = f\"Doubling time: {doubling_time}, Sample size: {sample_size}, Sites: {sites}, Annual Cost: {costs}\"\n    results = simulate_many(inputs, n_simulations)\n    plot_simulation(results, label)\n    median = np.median(results)\n    print(f\"Doubling time: {doubling_time}, Sample size: {sample_size}, Sites: {sites}\")\n    print(f\"Cost: {costs}, Median cumulative incidence: {median}\")\n```\n\n\n```{python}\n\nplt.figure(figsize=(10, 6), dpi=600)\nplt.xlabel(\"%\")\nplt.ylabel(\"Cumulative Incidence\")\nplt.ylim(0, 0.08)\nplt.yticks(np.arange(0, 0.09, 0.01), [f'{x*100:.0f}%' for x in np.arange(0, 0.09, 0.01)])\nplt.title(f\"Cumulative Incidence across 1000 simulations\")\nplt.grid(True, linestyle=\"--\", alpha=0.7)\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\n\nsample_sizes = [\n    100, 200, 400\n]\n\nfor sample_size in sample_sizes:\n    cost_per_swab = 5\n    max_swabs_per_site = 50\n    within_city_sampling_sites = math.ceil(sample_size / max_swabs_per_site)\n    labor_cost_per_50_swabs = 4 * 2 * 30 # 4 hours, 2 people, $30/hour\n    sample_cost = within_city_sampling_sites * labor_cost_per_50_swabs + cost_per_swab * sample_size\n    inputs = Inputs.create_default()\n    inputs.sampling_params.sample_population = sample_size\n    inputs.sampling_params.sample_cost = sample_cost\n    run_simulation(inputs)\n\nplt.legend()\nplt.show()\n\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<!-- ```{python}\n#Unneeded stuff\n\n\n\n@dataclass\nclass SamplingSite:\n    name: str\n    cost_per_sample: Decimal\n    capital_cost: Decimal\n    num_samples: int\n    staff_cost: Decimal\n    staff_hours: Decimal\n    num_staff: int\n    city: str\n    area: Optional[float] = None\n\n    def daily_cost(self):\n        sample_costs = self.cost_per_sample * self.num_samples\n        staff_costs = self.staff_cost * self.staff_hours * self.num_staff\n        return sample_costs + staff_costs\n\n    def __repr__(self) -> str:\n        return (f\"SamplingSite(name='{self.name}', cost_per_sample={self.cost_per_sample}, \"\n                f\"num_samples={self.num_samples}, staff_cost={self.staff_cost}, \"\n                f\"staff_hours={self.staff_hours}, num_staff={self.num_staff}, \"\n                f\"city='{self.city}', area={self.area})\")\n\n\nclass PathogenProperties:\n    name: str\n    relative_abundance_distribution: List[float]\n    doubling_time: int\n    genome_length: int\n\nclass Sequencer:\n    name: str\n    cost_per_run: Decimal\n    capital_cost: Decimal\n    sequencing_depth: int\n    read_length: int\n    processing_delay: int\n\n``` -->"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"png","fig-dpi":600,"df-print":"paged","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":true,"code-overflow":"scroll","code-link":true,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.10","title":"Costing out a Pooled Swab Sampling Program.","subtitle":"How much would it cost to build and run a pooled swab sampling program?","author":"Simon Grimm","date":"2024-07-30","categories":["Swab sampling","Modeling"],"draft":true,"jupyter":"venv","cap-location":"bottom"},"extensions":{"book":{"multiFile":true}}}},"draft":true,"projectFormats":["html"]}
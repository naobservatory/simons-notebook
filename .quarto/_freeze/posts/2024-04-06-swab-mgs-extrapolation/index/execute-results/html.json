{
  "hash": "009fe712569ca41017d36a35750e726e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Modeling routine swab sampling of asymptomatic individuals\nsubtitle: Sequencing swabs in non-hospital settings could offer cheap and sensitive pathogen early detection\nauthor: Simon Grimm\ndate: '2024-04-06'\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n    code-link: true\n    df-print: paged\neditor: visual\ntoc: true\nfilters:\n  - black-formatter\n---\n\n\n::: {#define-functions .cell execution_count=2}\n``` {.python .cell-code}\ndef simulate_many_p2ra(shedding_values: List[float] = [0.01],\n                     sample_populations: List[int] = [100],\n                     n_simulations: int = 1000) -> pd.DataFrame:\n\n    results = defaultdict(list)\n    for sample_pop in sample_populations:\n        for _ in range(n_simulations):\n            results[sample_pop].append(simulate_p2ra(sample_pop, shedding_values))\n    for key, values in results.items():\n        results[key] = sorted(values)\n    df = pd.DataFrame(results)\n    return df\n\n\n\ndef simulate_many_cum_inc(shedding_values: List[float] = [0.01],\n                     sample_populations: List[int] = [100],\n                     n_simulations: int = 1000) -> pd.DataFrame:\n\n    results = defaultdict(list)\n    for sample_pop in sample_populations:\n        for _ in range(n_simulations):\n            results[sample_pop].append(simulate_cum_inc(sample_pop, shedding_values))\n    for key, values in results.items():\n        results[key] = sorted(values)\n    df = pd.DataFrame(results)\n    return df\n\ndef simulate_cum_inc(sample_pop=100, shedding_values=[0.01]):\n    day = 0\n    population = 1e10\n    processing_delay = 4\n    n_sites = 1\n    n_min_observations = 2 # check what this means.\n    epsilon = 0.000001\n    genome_length_covid = 30_000\n    sequencing_depth = 8e5\n    read_length_usable = 10000 # Nanopore MinION\n\n    sigma_shedding_values = 0.05\n\n    doubling_time = 3\n    cv_doubling_time = 0.1\n    shedding_duration = 5\n    sigma_shedding_duration = 0.05\n\n\n    should_sample = {\n        0: True,\n        1: True,\n        2: True,\n        3: True,\n        4: True,\n        5: False,\n        6: False,\n\n    }\n\n    should_sequence = {\n        0: True,\n        1: True,\n        2: True,\n        3: True,\n        4: True,\n        5: False,\n        6: False,\n    }\n\n    r = math.log(2) / get_input_cv(doubling_time, cv_doubling_time, epsilon)\n    growth_factor = math.exp(r)\n    cumulative_incidence = 1 / population\n\n    detectable_days = get_input_sigma(shedding_duration,sigma_shedding_duration, epsilon)\n\n    ra_sicks = get_inputs_biased(shedding_values, sigma_shedding_values, epsilon)\n\n    observations = 0\n\n    site_infos = []\n    for site in range(n_sites):\n        site_infos.append({\n            \"sample_sick\": 0,\n            \"sample_total\": 0,\n            \"day_offset\": random.randint(0, 6)  # Random day of the week\n        })\n\n\n    read_length_usable = min(read_length_usable, genome_length_covid) # not needed because we assume Illumina, but let's keep it for now\n\n    #if low_quality_checked():\n    #    read_length_usable = min(read_length_usable, 120)\n    # CHECK, is this a condition I want to drop?\n    fraction_useful_reads = read_length_usable / genome_length_covid\n\n    v_processing_delay_factor = pow(growth_factor, processing_delay)\n    n_reads = sequencing_depth\n\n\n    while True:\n        day += 1\n        cumulative_incidence *= growth_factor\n\n\n        for site_info in site_infos:\n            day_of_week = (day + site_info[\"day_offset\"]) % 7\n            if should_sample[day_of_week]:\n                daily_incidence = cumulative_incidence * r\n                individual_probability_sick = 0\n                effective_incidence = daily_incidence\n                for _ in range(int(detectable_days)):\n                    individual_probability_sick += effective_incidence\n                    effective_incidence /= growth_factor\n                n_sick = np.random.poisson(sample_pop * individual_probability_sick)\n                site_info[\"sample_sick\"] += n_sick\n                site_info[\"sample_total\"] += sample_pop\n\n            if should_sequence[day_of_week]:\n                ra_sick = 0\n                if site_info[\"sample_sick\"] == 0:\n                    ra_sick = 0\n                elif len(ra_sicks) == 1: # \n                    ra_sick = ra_sicks[0]\n                else:\n                    for _ in range(site_info[\"sample_sick\"]):\n                        ra_sick += ra_sicks[random.randint(0, len(ra_sicks) - 1)]\n                    ra_sick = ra_sick / site_info[\"sample_sick\"]\n\n                probability_read_is_useful = (\n                    site_info[\"sample_sick\"] /\n                    site_info[\"sample_total\"] *\n                    ra_sick * fraction_useful_reads # TODO: this assumes an engineered virus.\n                )\n                #if 0.009 <= cumulative_incidence <= 0.011:\n                #    p2ra1 = site_info[\"sample_sick\"] / site_info[\"sample_total\"] * ra_sick\n                #    print(f\"incidence:{cumulative_incidence}, p2ra1:{p2ra1}\")\n\n\n                site_info[\"sample_sick\"] = 0\n                site_info[\"sample_total\"] = 0\n\n                # If this is zero it means that we didn't have any sick\n                # people in our sample, so we don't need to check if we\n                # observed any useful reads.\n                if probability_read_is_useful > 0:\n                    observations += np.random.poisson(n_reads * probability_read_is_useful)\n                    if observations >= n_min_observations:\n                        return cumulative_incidence * v_processing_delay_factor\n\n        if cumulative_incidence > 1 or day > 365 * 10:\n            return 1\n\n\ndef simulate_p2ra(sample_pop=100, shedding_values=[0.01]):\n    day = 0\n    population = 1e10\n    processing_delay = 4\n    n_sites = 1\n    n_min_observations = 2 # check what this means.\n    epsilon = 0.000001\n    genome_length_covid = 30_000\n    sequencing_depth = 8e5\n    read_length_usable = 10000 # Nanopore MinION\n\n    sigma_shedding_values = 0.05\n\n    doubling_time = 3\n    cv_doubling_time = 0.1\n    shedding_duration = 5\n    sigma_shedding_duration = 0.05\n\n\n    should_sample = {\n        0: True,\n        1: True,\n        2: True,\n        3: True,\n        4: True,\n        5: False,\n        6: False,\n\n    }\n\n    should_sequence = {\n        0: True,\n        1: True,\n        2: True,\n        3: True,\n        4: True,\n        5: False,\n        6: False,\n    }\n\n    r = math.log(2) / get_input_cv(doubling_time, cv_doubling_time, epsilon)\n    growth_factor = math.exp(r)\n    cumulative_incidence = 1 / population\n\n    detectable_days = get_input_sigma(shedding_duration,sigma_shedding_duration, epsilon)\n\n    ra_sicks = get_inputs_biased(shedding_values, sigma_shedding_values, epsilon)\n\n    observations = 0\n\n    site_infos = []\n    for site in range(n_sites):\n        site_infos.append({\n            \"sample_sick\": 0,\n            \"sample_total\": 0,\n            \"day_offset\": random.randint(0, 6)  # Random day of the week\n        })\n\n\n    read_length_usable = min(read_length_usable, genome_length_covid) # not needed because we assume Illumina, but let's keep it for now\n\n    #if low_quality_checked():\n    #    read_length_usable = min(read_length_usable, 120)\n    # CHECK, is this a condition I want to drop?\n    fraction_useful_reads = read_length_usable / genome_length_covid\n\n    v_processing_delay_factor = pow(growth_factor, processing_delay)\n    n_reads = sequencing_depth\n\n\n    while True:\n        day += 1\n        cumulative_incidence *= growth_factor\n\n        for site_info in site_infos:\n            day_of_week = (day + site_info[\"day_offset\"]) % 7\n            if should_sample[day_of_week]:\n                daily_incidence = cumulative_incidence * r\n                individual_probability_sick = 0\n                effective_incidence = daily_incidence\n                for _ in range(int(detectable_days)):\n                    individual_probability_sick += effective_incidence\n                    effective_incidence /= growth_factor\n                n_sick = np.random.poisson(sample_pop * individual_probability_sick)\n                site_info[\"sample_sick\"] += n_sick\n                site_info[\"sample_total\"] += sample_pop\n\n            if should_sequence[day_of_week]:\n                ra_sick = 0\n                if site_info[\"sample_sick\"] == 0:\n                    ra_sick = 0  # not technically true, but unused in this case.\n                else:\n                    for _ in range(site_info[\"sample_sick\"]):\n                        ra_sick += ra_sicks[random.randint(0, len(ra_sicks) - 1)]\n                    ra_sick = ra_sick / site_info[\"sample_sick\"]\n                relative_abundance = site_info[\"sample_sick\"] / site_info[\"sample_total\"] * ra_sick\n\n                if cumulative_incidence > 0.01:\n                    return relative_abundance\n\n\ndef get_input_sigma(geom_mean, sigma, epsilon):\n\n    if sigma < epsilon:\n        return geom_mean\n\n    return np.random.lognormal(math.log(geom_mean), sigma)\n\ndef get_input_cv(doubling_time, cv_doubling_time, epsilon):\n    mean = doubling_time\n    cv = cv_doubling_time\n\n    if cv < epsilon:\n        return mean\n\n    stdev = cv * mean\n    return np.random.normal(mean, stdev)\n\n\ndef get_inputs_biased(shedding_values, sigma_shedding_values, epsilon):\n    empirical_values = shedding_values\n    sigma = sigma_shedding_values\n    if sigma < epsilon:\n        return empirical_values\n\n    # Don't want to bias each mean independently, bias all of them\n    # together with log-normally distributed noise. The geometric mean\n    # (and median) of the noise is zero, and the standard deviation is\n    # provided by the user.\n\n    bias = np.random.lognormal(0, sigma)\n\n    adjusted_values = [empirical_value * bias for empirical_value in empirical_values]\n    return adjusted_values\n\ndef format_func(value, tick_number):\n    return r'$10^{{{}}}$'.format(int(value))\n\ndef return_studies():\n    df_op_lu = pd.read_csv('data/lu_throat_ct_mgs.tsv', sep='\\t', skiprows=1)\n    df_op_lu.rename(columns={'SCV-2 Relative Abundance': 'scv2_ra', 'Ct value': 'scv2_ct'}, inplace=True)\n    df_op_lu['patient_status'] = 'Inpatient'\n    df_np_babiker = pd.read_csv('data/babiker_np_ct_mgs.tsv', sep='\\t', skiprows=1)\n    df_np_babiker.rename(columns={'SARS-CoV-2 RT-PCR Ct': 'scv2_ct', 'SARS-CoV-2 RA': 'scv2_ra', 'Inpatient/ED vs. Outpatient': 'patient_status'}, inplace=True)\n    df_np_mostafa = pd.read_csv('data/mostafa_np_scv2_ct_mgs.tsv', sep='\\t', skiprows=1)\n    df_np_rodriguez = pd.read_csv('data/rodriguez_np_ct_mgs.csv', sep=';')\n\n    mostafa_severity_dict = {\n        1: \"Required\\nventilator\",\n        2: \"ICU\",\n        3: \"Inpatient\",\n        4: \"Outpatient\",\n        0: \"Unknown\"\n    }\n\n    df_np_mostafa.rename(columns={'SARS-CoV-2 RT-PCR Ct': 'scv2_ct', 'SARS-CoV-2 RA': 'scv2_ra'}, inplace=True)\n    df_np_mostafa['patient_status'] = df_np_mostafa['Severity Index'].astype(int).replace(mostafa_severity_dict)\n\n    rodriguez_patient_status_dict = {\n        \"Hospit\": \"Inpatient\",\n        \"Out_Patient\": \"Outpatient\",\n        \"Intensive_Care\": \"ICU\"\n    }\n\n    df_np_rodriguez['patient_status'] = df_np_rodriguez['Group'].replace(rodriguez_patient_status_dict)\n    df_np_rodriguez[\"scv2_ra\"] = df_np_rodriguez[\"Reads_2019_CoV\"] / df_np_rodriguez[\"Reads_Post_trimming\"]\n    df_np_rodriguez = df_np_rodriguez[df_np_rodriguez[\"scv2_ra\"] != 0] # Dropping Patient_066 because 0 ra breaks gmean\n\n    df_np_rodriguez.rename(columns={\"CoV_Ct_number\": \"scv2_ct\"}, inplace=True)\n\n    df_np_babiker['scv2_ct'] = df_np_babiker['scv2_ct'].replace(',', '.', regex=True).astype(float)\n\n    df_op_lu['patient_status'] = 'Inpatient'  # All inpatients for Lu et al.\n    df_np_babiker['patient_status'] = df_np_babiker['patient_status'].apply(lambda x: x if x in ['Inpatient', 'Outpatient'] else 'Unknown')\n\n    df_op_lu[\"swab_type\"] = \"op\"\n    df_np_babiker[\"swab_type\"] = \"np\"\n    df_np_rodriguez[\"swab_type\"] = \"np\"\n    df_np_mostafa[\"swab_type\"] = \"np\"\n    return [df_np_babiker, df_np_rodriguez, df_op_lu, df_np_mostafa]\n\ndef rpkm_to_ra(df):\n    genome_lengths_in_kb = {\n        \"Influenza A\": 13.5,\n        \"Influenza B\": 14.5,\n        \"Metapneumovirus\": 13.3,\n        \"Rhinovirus\": 7.2,\n        \"Parainfluenzavirus 1\": 15.5,\n        \"Parainfluenzavirus 3\": 15.5,\n        \"Parainfluenzavirus 4\": 17.4,\n        \"Respiratory Syncytial Virus\": 15.2\n    }\n\n\n\n    for virus, virus_length in genome_lengths_in_kb.items():\n        df.loc[df[\"virus\"] == virus, \"relative_abundance\"] = df.loc[df[\"virus\"] == virus, \"RPKM\"] * virus_length / 1e6\n\n    return df\n```\n:::\n\n\nThe NAO aims to detect stealth pathogens at an early stage. Initially we mostly thought about detecting pathogens in wastewater, but we've recently expanded our research to also cover [air sampling](https://naobservatory.org/reports/air-sampling-for-early-pathogen-detection), created a more general framework with which to think about the promise of different [sampling strategies](https://naobservatory.org/reports/comparing-sampling-strategies-for-early-detection-of-stealth-biothreats), and built a simulator that is agnostic to the [underlying sampling method](https://naobservatory.org/blog/simulating-approaches-to-metagenomic-pandemic-identification).\n\nOne sample type we've been thinking about more recently is swab sampling. Jeff Kaufman recently wrote a piece that provides an initial estimate of the [sensitivity of swab sampling](https://www.jefftk.com/p/sequencing-swabs). The post here expands on this initial piece of work by using our more relative abundance advanced simulator on a larger set of swab sampling studies. Additionally we create a BOTEC estimate for what relative abundances could look like in the kind of sampling program we envision (collect anterior nasal swabs (heretofore called nasal swabs) from a random sample of people at an airport terminal or some other public location).\n\nIn summary, ....\n\n### Lu et al. 2021\n\nJeff originally wrote a post that is based on Lu et al. 2021, which sampled Chinese patients with oropharyngeal swabs (throat, or OP swabs). The paper gives little information on patient characteristics. COVID-19 abundance in Lu et al. 2021 is fairly high with a mean relative abudance of 2x10<sup>-3</sup> (n=16).\n\n::: {#932019ef .cell execution_count=3}\n``` {.python .cell-code}\ndf_op_lu = pd.read_csv('data/lu_throat_ct_mgs.tsv', sep='\\t', skiprows=1)\ndf_op_lu.rename(columns={'SCV-2 Relative Abundance': 'scv2_ra', 'Ct value': 'scv2_ct'}, inplace=True)\n\nfig, ax = plt.subplots(figsize=(9, 4))\nsns_default_colors = sns.color_palette()\n\nx_lim = 12.5, 40\ny_lim = 10**-8, 2\n\nsns.scatterplot(ax=ax, data=df_op_lu, x='scv2_ct', y='scv2_ra', color=sns_default_colors[0], s=70)\nax.set_xlabel('SARS-CoV-2 qPCR CT Value')\nax.set_xlim(x_lim)\ny_lim_adjusted = (y_lim[0], y_lim[1] * 1.05)  # Adjust upper limit to ensure top dot is fully displayed\nax.set_ylim(y_lim_adjusted)\nax.set_title(\"Lu et al. 2021 - Throat Swabs\", x=0.00, y=1.0, ha='left')\n\nax.set_yscale('log')\nax.invert_xaxis()\nax.spines['right'].set_visible(False)\nax.spines['top'].set_visible(False)\nax.tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\nax.set_ylabel('Relative Abundance')\nfor x in np.arange(15, 40, 5):\n    ax.axvline(x=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\nfor y in range(-7, 1, 1):\n    log_y = 10**y\n    ax.axhline(y=log_y, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 1: qPCR CT values and relative abundance for Lu et al. 2021.**](index_files/figure-html/cell-4-output-1.png){width=748 height=376}\n:::\n:::\n\n\nWe can use this data to estimate the expected cumulative incidence upon detection. Let's say we get a random set of swabs on each weekday, pooling and sequencing them using a Nanopore MinION which produces 800,000 reads. We need two suspicious reads for detection (where there is only one genetic site within the pathogen that is suspicious). If we vary the number of swabs, ranging from 50 to 800, median cumulative incidence is expected to be 2% when sampling 50 swabs, 1.2% when sampling 100 swabs, 0.6 % at 200 swabs, 0.4% at 400 swabs, and 0.2% at 800 swabs. That's pretty good!\n\n::: {#bc9fdf83 .cell execution_count=4}\n``` {.python .cell-code}\ndf_op_lu_ras = df_op_lu['scv2_ra'].dropna().to_list()\nfig, ax = plt.subplots(figsize=(10,6),dpi=600)\nn_swab_range = [50, 100, 200, 400, 800]\nstudies = [\"Lu\"]\nfor i, (study, positive_ras) in enumerate(zip(studies, [df_op_lu_ras])):\n    df = simulate_many_cum_inc(positive_ras, n_swab_range)\n    ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:.0%}'.format(y)))\n\n    for n_swabs in n_swab_range:\n        ax.plot(df.index/10, df[n_swabs], label=f'{n_swabs} swabs')\n    ax.set_xlabel('Percentile')\n    ax.set_ylabel('Cumulative incidence')\n    #ax.set_yscale('log')\n    ax.yaxis.set_tick_params(labelleft=True)\n    ax.axvline(x=50, color='red', linestyle='--', alpha=0.5)\n    ax.axvline(x=10, color='red', linestyle='--', alpha=0.5)\n    ax.axvline(x=90, color='red', linestyle='--', alpha=0.5)\n\n    ymin, ymax = ax.get_ylim()\n    ax.text(x=51, y=ymax, s='Median', color='black', fontsize=10, ha='left')\n    ax.text(x=11, y=ymax, s='10%', color='black', fontsize=10, ha='left')\n    ax.text(x=91, y=ymax, s='90%', color='black', fontsize=10, ha='left')\n\n    for y in range(0, int(ymax*100), 1):\n        y = y/100\n        ax.axhline(y=y, color='black', linestyle='--', linewidth=0.3, alpha=0.2)\n\n    for x in range(0, 100, 10):\n        ax.axvline(x=x, color='black', linestyle='--', linewidth=0.3, alpha=0.2)\n\n    ax.tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\n    ax.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=True)\n    ax.set_xticks(range(0, 100, 10))\n\n    ax.set_xticklabels(['{}%'.format(x) for x in range(0, 100, 10)])\n\n    #ax.set_ylim(10**-10, 10**-1)\n\n    ax.set_xlabel('')\n\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n\n    ax.legend(title='', loc='upper center', bbox_to_anchor=(1.1, 0.6), ncol=1, frameon=False)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 2: Simulated cumulative incidence at time of detection for Lu et al. 2021.**\n Assuming swab sample sizes ranging from 50-800.](index_files/figure-html/cell-5-output-1.png){}\n:::\n:::\n\n\n::: {#d2269235 .cell execution_count=5}\n``` {.python .cell-code}\ndf_op_lu_ras = df_op_lu['scv2_ra'].dropna().to_list()\nprint(df_op_lu_ras)\nfig, ax = plt.subplots(figsize=(10,6),dpi=600)\nn_swab_range = [50, 100, 200, 400, 800]\nstudies = [\"Lu\"]\nfor i, (study, positive_ras) in enumerate(zip(studies, [df_op_lu_ras])):\n    df = simulate_many_p2ra(positive_ras, n_swab_range)\n    #ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: '{:.0%}'.format(y)))\n    median = df.iloc[len(df.index)//2]\n    print(median)\n    for n_swabs in n_swab_range:\n        ax.plot(df.index/10, df[n_swabs], label=f'{n_swabs} swabs')\n    ax.set_xlabel('Percentile')\n    ax.set_ylabel('Relative abundance')\n    ax.set_yscale('log')\n    #ax.yaxis.set_tick_params(labelleft=True)\n    ax.axvline(x=50, color='red', linestyle='--', alpha=0.5)\n    ax.axvline(x=10, color='red', linestyle='--', alpha=0.5)\n    ax.axvline(x=90, color='red', linestyle='--', alpha=0.5)\n\n    ymin, ymax = ax.get_ylim()\n    ax.text(x=51, y=ymax, s='Median', color='black', fontsize=10, ha='left')\n    ax.text(x=11, y=ymax, s='10%', color='black', fontsize=10, ha='left')\n    ax.text(x=91, y=ymax, s='90%', color='black', fontsize=10, ha='left')\n\n    for y in range(0, int(ymax*100), 1):\n        y = y/100\n        ax.axhline(y=y, color='black', linestyle='--', linewidth=0.3, alpha=0.2)\n\n    for x in range(0, 100, 10):\n        ax.axvline(x=x, color='black', linestyle='--', linewidth=0.3, alpha=0.2)\n\n    #ax.tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\n    #ax.tick_params(axis='x', which='both', bottom=False, top=False, labelbottom=True)\n    ax.set_xticks(range(0, 100, 10))\n\n    ax.set_xticklabels(['{}%'.format(x) for x in range(0, 100, 10)])\n\n    #ax.set_ylim(10**-10, 10**-1)\n\n    ax.set_xlabel('')\n\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n\n    ax.legend(title='', loc='upper center', bbox_to_anchor=(1.1, 0.6), ncol=1, frameon=False)\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[0.7906810992, 0.3526345717, 0.07381399234, 0.008229439428, 0.01337541209, 0.03370636741, 0.02162611358, 0.00607969494, 0.001031787891, 0.0008085669449, 0.0002981682692, 0.0001280181528, 0.0007181258632, 0.0001897416176, 4.763199294e-06, 3.741936232e-05]\n50     0.000003\n100    0.000007\n200    0.000032\n400    0.000038\n800    0.000041\nName: 500, dtype: float64\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure X: Simulated relative abundance at time of detection for Lu et al. 2021.**\n Assuming swab sample sizes ranging from 50-800.](index_files/figure-html/cell-6-output-2.png){}\n:::\n:::\n\n\nLet's take a closer look at the median outcome. If we run the simulation for each swab sample size between 50 and 800, pick the median cumulative incidence and plot the medians only we get the following curve. This still looks quite good: when we  use more than 200 swabs we reliably get a cumulative incidence that is below 1%. But what happens if we use a different study as our \"ground truth\" for the expected relative abundance in swabs?\n\n::: {#9f864673 .cell execution_count=6}\n``` {.python .cell-code}\ndf_op_lu_ras = df_op_lu['scv2_ra'].dropna().to_list()\nfig, ax = plt.subplots(figsize=(10,6),dpi=600)\nn_swab_range = range(50, 800, 1)\nstudies = [\"Lu\"]\nfor i, (study, positive_ras) in enumerate(zip(studies, [df_op_lu_ras])):\n    df = simulate_many_cum_inc(positive_ras, n_swab_range, n_simulations=100)\n    df_median = pd.DataFrame(df.iloc[len(df.index)//2])\n    df_median.columns = ['cumulative_incidence']\n    df_median.index.name = 'n_swabs'\n\n    ax.plot(df_median.index, df_median['cumulative_incidence'])\n\n    ax.set_xlabel('Swab sample size')\n    ax.set_ylabel('Cumulative incidence')\n\n    y_min, y_max = ax.get_ylim()\n    for y in np.arange(0, y_max, 0.005):\n        ax.axhline(y=y, color='black', linestyle='--', linewidth=0.3, alpha=0.2)\n    x_min, x_max = ax.get_xlim()\n    for x in np.arange(100, x_max, 100):\n        ax.axvline(x=x, color='black', linestyle='--', linewidth=0.3, alpha=0.2)\n\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    #ax.legend(title='', loc='upper center', bbox_to_anchor=(1.1, 0.6), ncol=1, frameon=False)\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 3: Simulated cumulative incidence at time of detection for Lu et al. 2021.**\n Median outcome for sample sizes between 1 and 800 swabs.](index_files/figure-html/cell-7-output-1.png){}\n:::\n:::\n\n\n### Additional SARS-CoV-2 studies\n\nLu et al. 2021 is a relatively small sample of inpatients in Wuhan but there are other studies that have done similar work. Limiting ourselves to COVID-19, there is Babiker et al. 2020, which sampled poth inpatients and outpatients using nasopharyngeal swabs, Mostafa et al. 2020, which sampled nasal swabs from patients which range from being outpatients to individuals that required a ventilator and Rodriguez et al. 2021, which sampled nasopharyngeal swabs from inpatients and outpatients. We call these studies \"target studies\" heretoforth. The average relative SARS-CoV-2 relative abundance for Babiker et al. 2020 is 2x10<sup>-4</sup> (n=44), 10<sup>-4</sup> for Mostafa et al. 2020 (n=33), and 1.2x10<sup>-3</sup>. This compares to a relative abudance of 2x10<sup>-3</sup> (n=16) in  Lu et al. 2021 (Fig 4).\n\n\n#### Version with one plot per study\n\n::: {#e6d1b917 .cell execution_count=7}\n``` {.python .cell-code}\ndf_np_babiker, df_np_rodriguez, df_op_lu, df_np_mostafa = return_studies()\n\nfig, axs= plt.subplots(4, 1, figsize=(7.5, 12),dpi=600)\nfig.subplots_adjust(hspace=0.3)\nstudies = [\"Lu et al. 2021\", \"Babiker et al. 2020\", \"Mostafa et al. 2020\", \"Rodriguez et al. 2021\"]\nfor ax, df, study in zip(axs, [df_op_lu, df_np_babiker, df_np_mostafa, df_np_rodriguez], studies):\n    sns_default_colors = sns.color_palette()\n    #viridis clor palette with 5 colors\n    viridis_colors = sns.color_palette(\"CMRmap\", 5)\n\n    x_lim = 12.5, 40\n    y_lim = 10**-8, 2\n    if study == \"Lu et al. 2021\":\n        sns.scatterplot(ax=ax, data=df, x='scv2_ct', y='scv2_ra', color=sns_default_colors[0], s=70)\n        ax.set_xlabel('')\n        ax.set_xlim(x_lim)\n        y_lim_adjusted = (y_lim[0], y_lim[1] * 1.05)  # Adjust upper limit to ensure top dot is fully displayed\n        ax.set_ylim(y_lim_adjusted)\n        ax.legend(labels=['Inpatient'], loc=\"center left\", bbox_to_anchor=(1, 0.5), frameon=False)\n        ax.set_title(study + \" - Throat Swabs\", x=0.00, y=1.0, ha='left')\n    elif study == \"Babiker et al. 2020\":\n        order = [\"Inpatient\", \"Outpatient\",]\n        sns.scatterplot(ax=ax, data=df, x='scv2_ct', y='scv2_ra', hue='patient_status', style='patient_status', palette=sns_default_colors, s=70, hue_order=order)\n        ax.set_xlabel('')\n        ax.legend(title='', loc=\"center left\", bbox_to_anchor=(1, 0.5), frameon=False)\n        ax.set_xlim(x_lim)\n        ax.set_ylim(y_lim)\n        ax.set_title(study + \" - NP Swabs\", x=0.00, y=1.0, ha='left')\n    elif study == \"Mostafa et al. 2020\":\n        sns.scatterplot(ax=ax, data=df, x='scv2_ct', y='scv2_ra', hue='patient_status', palette=sns_default_colors, s=70, style='patient_status')\n        ax.set_xlabel('')\n        ax.set_xlim(x_lim)\n        ax.set_ylim(y_lim)\n        ax.legend(title='', loc=\"center left\", bbox_to_anchor=(1, 0.5), frameon=False)\n        ax.set_title(study + \" - NP Swabs\", x=0.00, y=1.0, ha='left')\n    elif study == \"Rodriguez et al. 2021\":\n        order = [\"Inpatient\", \"Outpatient\", \"ICU\"]\n        sns.scatterplot(ax=ax, data=df, x='scv2_ct', y='scv2_ra', hue='patient_status', style='patient_status', s=70, hue_order=order)\n        ax.set_xlabel('SARS-CoV-2 qPCR CT Value')\n        ax.legend(title='', loc=\"center left\", bbox_to_anchor=(1, 0.5), frameon=False)\n        ax.set_xlim(x_lim)\n        ax.set_ylim(y_lim)\n        ax.set_title(study + \" - NP Swabs\", x=0.00, y=1.0, ha='left')\n\n\n    ax.set_yscale('log')\n    ax.invert_xaxis()\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\n    ax.set_ylabel('Relative Abundance')\n    for x in np.arange(15, 40, 5):\n        ax.axvline(x=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n    for y in range(-7, 1, 1):\n        log_y = 10**y\n        ax.axhline(y=log_y, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 4: SARS-CoV-2 qPCR CT vs SARS-CoV-2 RA.**\nFirst Figure: Throat Swabs. Data from Lu et al. 2021. Second Figure: NP Swabs. Data from Babiker et al. 2020. Third Figure: Nasal Swabs. Data from Mostafa et al. 2020. Fourth Figure: Nasal Swabs. Data from Rodriguez et al. 2021.](index_files/figure-html/cell-8-output-1.png){}\n:::\n:::\n\n\n#### Version with several studies per plot\n\n::: {#3e4c0982 .cell execution_count=8}\n``` {.python .cell-code}\ndf_np_babiker, df_np_rodriguez, df_op_lu, df_np_mostafa = return_studies()\n\nfig, axs = plt.subplots(2, 1, figsize=(9, 8), dpi=600)\nfig.subplots_adjust(hspace=0.33)\n\n\ndf_op_lu['study'] = \"Lu et al. 2021\"\ndf_np_babiker['study'] = \"Babiker et al. 2020\"\ndf_np_mostafa['study'] = \"Mostafa et al. 2020\"\ndf_np_rodriguez['study'] = \"Rodriguez et al. 2021\"\ncombined_df = pd.concat([df_op_lu, df_np_babiker, df_np_mostafa, df_np_rodriguez])\n\n# First subplot: Data points styled by study\npalette = sns.color_palette(\"viridis\", n_colors=combined_df['study'].nunique())\nscatter = sns.scatterplot(ax=axs[0], data=combined_df, x='scv2_ct', y='scv2_ra', hue='study', style='study', palette=palette)\naxs[0].set_title(\"a\", x=-0.08, y=1.0, ha='left', fontsize=10, fontweight='bold')\naxs[0].set_xlabel('')\naxs[0].set_ylabel('')\naxs[0].set_yscale('log')\n\n\nhandles, labels = axs[0].get_legend_handles_labels()\norder = [labels.index('Lu et al. 2021'), labels.index('Rodriguez et al. 2021'), labels.index('Babiker et al. 2020'), labels.index('Mostafa et al. 2020')]\naxs[0].legend([handles[idx] for idx in order], [labels[idx] for idx in order], title='', loc=\"lower center\", bbox_to_anchor=(0.5, -0.3), frameon=True, ncol=2, fontsize=8)\n\n\n\n# Second subplot: Data points styled by patient status\nsns.scatterplot(ax=axs[1], data=combined_df, x='scv2_ct', y='scv2_ra', hue='patient_status', style='patient_status')\naxs[1].set_title(\"b\", x=-0.08, y=1.0, ha='left', fontsize=10, fontweight='bold')\naxs[1].set_xlabel('')\naxs[1].set_ylabel('')\naxs[1].set_yscale('log')\naxs[1].legend(title='', loc=\"center left\", bbox_to_anchor=(1, 0.5), frameon=False)\n\nhandles, labels = axs[1].get_legend_handles_labels()\norder = [labels.index('Outpatient'), labels.index('Inpatient'), labels.index('Required\\nventilator'), labels.index('ICU'), labels.index('Unknown')]\naxs[1].legend([handles[idx] for idx in order], [labels[idx] for idx in order], title='', loc=\"lower center\", bbox_to_anchor=(0.5, -0.33),frameon=True, ncol=3, fontsize=8)\n# Common settings for both plots\nfor ax in axs:\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\n    x_lim = 12.5, 40\n    y_lim = 10**-8, 2\n    ax.set_xlim(x_lim)\n    y_lim_adjusted = (y_lim[0], y_lim[1] * 1.05)  # Adjust upper limit to ensure top dot is fully displayed\n    ax.set_ylim(y_lim_adjusted)\n    for x in np.arange(15, 40, 5):\n        ax.axvline(x=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5, zorder=-1)\n    for y in range(-7, 1, 1):\n        log_y = 10**y\n        ax.axhline(y=log_y, color='grey', linestyle='--', alpha=0.5, linewidth=0.5, zorder=-1)\n    ax.invert_xaxis()\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 4: SARS-CoV-2 qPCR CT vs SARS-CoV-2 RA.**\nFirst subplot: Data from all studies with study-based styling. Second subplot: Data from all studies with patient status-based styling.](index_files/figure-html/cell-9-output-1.png){}\n:::\n:::\n\n\n\n\nLet's recreate Figure 3 for these new studies. Again, we assume a swab sampling program that sampled 50-800 swabs a day. If we take the relative abundance values of these three studies as the relative abundance we'd expect to see in a swab sampling program Lu et al. 2021 shows a cumulative incidence of 0.6% (200 swabs) and 0.3 % (400 swabs), Babiker et al. 2020 shows 1.2% and 0.9%, Mostafa et al. 2020 1.7% and 1.4% and Rodriguez et al. 0.7% and 0.3% respectively.\n\n::: {#f86aee83 .cell execution_count=11}\n\n::: {.cell-output .cell-output-display}\n![**Figure 5: Simulated cumulative incidence for Lu et al. 2021, Babiker et al. 2020, Mostafa et al. 2020, and Rodriguez et al. 2021.**\n Assuming swab sample sizes between 50 and 800.](index_files/figure-html/cell-12-output-1.png){width=672 height=671}\n:::\n:::\n\n\n::: {#bdba53f7 .cell execution_count=12}\n\n::: {.cell-output .cell-output-display}\n![**Figure Y: Simulated RA(1%) for Lu et al. 2021, Babiker et al. 2020, Mostafa et al. 2020, and Rodriguez et al. 2021.**](index_files/figure-html/cell-13-output-1.png){}\n:::\n:::\n\n\n## What would a more representative sample look like?\n\nThe studies we've looked at all have issues that keep them from being representative of the sort of population sampling we're considering. There are four different aspects we can look at:\n\n1. Most patients were hospitalized, but in a hypothetical sampling program individuals would either be asymptomatic or only slightly sick (otherwise they would stay home)\n2. Likely close to all patients were symptomatic, but the kind of stealth pathogen we are looking for would be expected to show no symptoms.\n3. Studies either used nasopharyngeal swabs ( Babiker et al. 2020, Mostafa et al. 2020, and Rodriguez et al. 2021), or oropharyngeal swabs (Lu et al. 2021) but a sampling program would most likely use anterior nasal swabs.\n4. Finally, many of the inpatients covered by our four target studies were sampled later in their disease course, but viral loads are highest just when symptoms begin. But when sampling asymptomatic individuals the time between testing and initial infection would likely be random and sampling could thus occur more closely to the start of symptoms when compared to inpatients.\n\nLet's see if we can get an intuition for the magnitude for these effects.\n\n\n### Swab type\n\n#### Nasopharyngeal vs Nasal swabs\n\nBoth Babiker et al. 2020, Mostafa et al. 2020, and Rodriguez et al. 2021 used nasopharyngeal swabs. We found five studies that performed paired sampling and SARS-CoV-2 qPCR of the same patients: Patriquin et al. 2022, McCulloch et al. 2020, Pere et al 2020, Kojima et al. 2020, and Tu et al. 2020. For each of these studies we have individual data points for each sample pair. By computing the CT difference within each pair, and averaging these differences we get an average CT difference for each study (Table S1, Fig.6). Averaging these values again without weighing studies we get an average difference of **-1.82** CT values, where negative values mean that nasopharyngeal swabs have lower CT values and are thus more sensitive.\n\n\n::: {#cell-np_nasal_ct_plot .cell execution_count=14}\n``` {.python .cell-code}\ndf = pd.read_csv('data/np-nasal-ct.tsv', sep='\\t', skiprows=1)\n\ndf = df.melt(var_name='Study', value_name='CT Difference')\n\n\npretty_study_names = {\n    \"Patriquin2022\": \"Patriquin et al. 2022\",\n    \"McCulloch2020\": \"McCulloch et al. 2020\",\n    \"Pere2020\": \"Pere et al. 2020\",\n    \"Kojima2020\": \"Kojima et al. 2020\",\n    \"Tu2020\": \"Tu et al. 2020\"\n}\n\ndf['Study'] = df['Study'].map(pretty_study_names).values\n\nmean_ct_diff = df.groupby('Study', as_index=False)['CT Difference'].mean()\nfig = plt.figure(figsize=(8, 4),dpi=600)\n\n\n\nsns.stripplot(data=df, y='Study', x='CT Difference', hue='Study', jitter=True,zorder=-1)\nsns.pointplot(data=mean_ct_diff, y='Study', x='CT Difference', linestyles='none', markers='D', color='#36454F', markersize=5, errorbar=None,zorder=1)\n\nplt.legend([],[], frameon=False)\nplt.ylabel('')\nplt.xlabel('SARS-CoV-2 qPCR CT Δ (NP - Nasal)')\nplt.tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\n\n\n\nx_min, x_max = plt.xlim()\n#round up xmin and xmax to the nearest 5\nx_min = math.ceil(x_min / 5) * 5\nx_max = math.ceil(x_max / 5) * 5\n\nx_marks = np.arange(x_min, x_max, 2.5)\nfor x in x_marks:\n    plt.axvline(x=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n\n\n\nplt.axvline(x=0, color='red', linestyle='--', alpha=0.5)\n\n#plt.xticks(x_marks)\n\n\nmin_x, max_x = plt.xlim()\n\nplt.text(max_x/2,-0.6, 'Favors Nasal', fontsize=10, color='black', ha='center')\nplt.text(min_x/2,-0.6, 'Favors Nasopharyngeal', fontsize=10, color='black', ha='center')\n\nplt.gca().spines['right'].set_visible(False)\nplt.gca().spines['top'].set_visible(False)\nplt.gca().spines['left'].set_visible(False)\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 6: Nasal swabs vs nasopharyngeal swabs.** Data from Patriquin et al. 2022, McCulloch et al. 2020, Pere et al. 2020, Kojima et al. 2020, and Tu et al. 2020.](index_files/figure-html/np_nasal_ct_plot-output-1.png){#np_nasal_ct_plot}\n:::\n:::\n\n\n##### Oropharyngeal vs Nasal swabs\n\nLu et al. 2021 uses oropharyngeal swabs. We can adjust this swab type by looking at the studies , Leungt et al. 2022, Goodall et al. 2022 and Berenger et al. 2020. We have raw data for Goodall et al. 2022, Leung et al. 2020, and median CT values for Berenger et al. 2022. Averaging the qPCR results for qPCR target N and ORF1a for each sample, Goodall et al. 2022 showed an average CT value difference (OP-Nasal) of **1** Ct value in favor of nasal swabs. In Berenger et al. 2022 the difference between medians (OP - NP) was 1.1 (E gene) and 0.8 (RdRp). This gives an across-study average difference of 1 CT value, maing OP swabs less sensitive than nasal swabs.\n\n::: {#7b17cac3 .cell execution_count=15}\n``` {.python .cell-code}\ndf = pd.read_csv('data/goodall-op-nasal-ct.tsv', sep='\\t', skiprows=1)\npretty_study_names = {\n    \"Goodall2022\": \"SARS-CoV-2\",\n    \"Leung2022\": \"Leung et al. 2020\",\n}\ndf = df.melt(var_name='Study', value_name='CT Difference')\ndf['Study'] = df['Study'].map(pretty_study_names).values\nmean_ct_diff = df.groupby('Study', as_index=False)['CT Difference'].mean()\n\nfig, axs = plt.subplots(2, 1, figsize=(8,4),  dpi=600, gridspec_kw={'height_ratios': [1.5, 3]})\n\n\nfig.subplots_adjust(hspace=0.6)\n\nsns.stripplot(data=df, y='Study', x='CT Difference', hue='Study', jitter=True, zorder=-1, ax=axs[0])\nsns.pointplot(data=mean_ct_diff, y='Study', x='CT Difference', linestyles='none', markers='D', color='#36454F', markersize=5, errorbar=None, zorder=1, ax=axs[0])\naxs[0].legend([],[], frameon=False)\n\n\naxs[0].set_ylabel('')\naxs[0].set_xlabel(u'SARS-CoV-2 qPCR CT Δ (OP - Nasal)')\naxs[0].tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\naxs[0].text(-0.25, 1.4, 'Fig. 7A: Goodall et al. 2022', transform=axs[0].transAxes, fontsize=10, verticalalignment='top', horizontalalignment='left')\nx_min, x_max = axs[0].get_xlim()\n#round up xmin and xmax to the nearest 5\nx_min = math.ceil(x_min / 5) * 5\nx_max = math.ceil(x_max / 5) * 5\n\nx_marks = np.arange(x_min, x_max, 2.5)\nfor x in x_marks:\n    axs[0].axvline(x=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\naxs[0].axvline(x=0, color='red', linestyle='--', alpha=0.5)\n\naxs[0].axhline(y=0.5, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n\nmin_x, max_x = axs[0].get_xlim()\n\naxs[0].text(max_x/2,-0.6, 'Favors Nasal Swab', fontsize=9, color='black', ha='center')\naxs[0].text(min_x/2,-0.6, 'Favors Oro-pharyngeal', fontsize=9, color='black', ha='center')\n\n\naxs[0].spines['right'].set_visible(False)\naxs[0].spines['top'].set_visible(False)\naxs[0].spines['left'].set_visible(False)\n\ndf = pd.read_csv('data/leung_genome_copy_differences.tsv', sep='\\t', skiprows=1)\n\ndf = df.melt(var_name='Study & Comparison', value_name='Genome Copy Number Difference')\ndf['Study & Comparison'] = df['Study & Comparison'].str.split(',').str[-1]\nmean_ct_diff = df.groupby('Study & Comparison')['Genome Copy Number Difference'].mean().reset_index()\n\nsns.stripplot(data=df, y='Study & Comparison', x='Genome Copy Number Difference', hue='Study & Comparison', jitter=True, alpha=0.6, zorder=1, ax=axs[1])\nsns.pointplot(data=mean_ct_diff, y='Study & Comparison', x='Genome Copy Number Difference', linestyles='none', markers='D', color='#36454F', markersize=5, errorbar=None, zorder=1, ax=axs[1])\nplt.legend([],[], frameon=False)\n# drop y axis label\naxs[1].set_ylabel('')\naxs[1].set_xlabel(u'Genome Copy Number Δ (Nasal - OP), Logged')\naxs[1].text(-0.25, 1.1, 'Fig. 7B: Leung et al. 2020', transform=axs[1].transAxes, fontsize=10, verticalalignment='top', horizontalalignment='left')\n\n# flip x axis\naxs[1].tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\nfor x in -2, 0, 2, 4, 6:\n    if x == 0:\n        axs[1].axvline(x=x, color='red', linestyle='--', alpha=0.5)\n        continue\n    axs[1].axvline(x=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n\nfor y in 0.5, 1.5:\n    axs[1].axhline(y=y, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n\nmin_x, max_x = axs[1].get_xlim()\n\n\naxs[1].spines['right'].set_visible(False)\naxs[1].spines['top'].set_visible(False)\naxs[1].spines['left'].set_visible(False)\n\nplt.show()\n\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 7: Nasal swabs vs Oro-pharyngeal swabs.** Data is taken from Goodall et al. 2022 and Leung et al 2020.](index_files/figure-html/cell-16-output-1.png){}\n:::\n:::\n\n\n### Inpatient vs Outpatient\n\n::: {#cell-target-studies-patient-composition .cell execution_count=16}\n``` {.python .cell-code}\ndf_np_babiker, df_np_rodriguez, df_op_lu, df_np_mostafa = return_studies()\norder = ['Inpatient', 'Outpatient', 'Required\\nventilator', 'ICU', 'Unknown']\n\nlu_counts = df_op_lu['patient_status'].value_counts().reindex(order)\nbabiker_counts = df_np_babiker['patient_status'].value_counts().reindex(order)\nmostafa_counts = df_np_mostafa['patient_status'].value_counts().reindex(order)\nrodriguez_counts = df_np_rodriguez['patient_status'].value_counts().reindex(order).dropna()\n\nprint(\"Lu\", lu_counts)\nprint(\"Babiker\", babiker_counts)\nprint(\"Mostafa\", mostafa_counts)\nprint(\"Rodriguez\", rodriguez_counts)\nfig, axs = plt.subplots(1, 4, figsize=(12, 4), width_ratios=[0.7, 1.5, 4, 2.4], sharey=True, dpi=800)\n\ncolors = sns.color_palette()\ncolor_dict = {\n   'Inpatient': colors[0],\n    'Outpatient': colors[1],\n    'Required\\nventilator': colors[2],\n    'ICU': colors[3],\n    'Unknown': colors[4]\n}\n\naxs[0].bar(lu_counts.index, lu_counts.values, color=color_dict['Inpatient'], width=0.5)\naxs[0].set_title('Lu et al. 2021')\naxs[0].set_ylabel('Count')\naxs[0].set_ylim(0, max(lu_counts.values) + 5)\n\naxs[1].bar(babiker_counts.index, babiker_counts.values, color=[color_dict[x] for x in babiker_counts.index], width=0.8)\naxs[1].set_title('Babiker et al. 2020')\naxs[1].set_ylim(0, max(babiker_counts.values) + 5)\n\naxs[2].bar(mostafa_counts.index, mostafa_counts.values, color=[color_dict[x] for x in mostafa_counts.index])\naxs[2].set_title('Mostafa et al. 2020')\naxs[2].set_ylim(0, max(mostafa_counts.values) + 10)\naxs[2].set_yticks(np.arange(0, max(mostafa_counts.values) + 30, 10))\n\naxs[3].bar(rodriguez_counts.index, rodriguez_counts.values, color=[color_dict[x] for x in rodriguez_counts.index])\naxs[3].set_title('Rodriguez et al. 2021')\naxs[3].set_ylim(0, max(rodriguez_counts.values) + 5)\naxs[3].set_yticks(np.arange(0, max(rodriguez_counts.values) + 10, 5))\n\nfor ax in axs:\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.tick_params(axis='y', which='both', left=False, right=False, labelleft=True)\n    ax.tick_params(axis='x', which='both', top=False, bottom=False, labeltop=False, labelbottom=True)\n    ax.set_ylabel('')\n    for x in np.arange(0, 40, 10):\n        ax.axhline(y=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5, zorder=-1)\n\nplt.tight_layout()\nplt.show()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLu patient_status\nInpatient               16.0\nOutpatient               NaN\nRequired\\nventilator     NaN\nICU                      NaN\nUnknown                  NaN\nName: count, dtype: float64\nBabiker patient_status\nInpatient               34.0\nOutpatient              10.0\nRequired\\nventilator     NaN\nICU                      NaN\nUnknown                  NaN\nName: count, dtype: float64\nMostafa patient_status\nInpatient                1\nOutpatient               3\nRequired\\nventilator    20\nICU                      6\nUnknown                  3\nName: count, dtype: int64\nRodriguez patient_status\nInpatient     17.0\nOutpatient    42.0\nICU           44.0\nName: count, dtype: float64\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure 8: Patient composition of Lu et al. 2021, Babiker et al. 2020, Mostafa et al. 2020, and Rodriguez et al. 2021.**](index_files/figure-html/target-studies-patient-composition-output-2.png){#target-studies-patient-composition}\n:::\n:::\n\n\nWe can adjust for this somewhat by looking at the average difference of the CT values for inpatients and outpatients (Table 1). It's worth noting that inpatients typically have **higher** CT values, which is unexpected, given that they are likely to be sicker.\n\n| Study | Sample size | Sample type| Inpatient CT (median, IQR) | Outpatient CT (median, IQR) | CT value difference (Inpatient - Outpatient)|\n|-------|-------------|------------|----------------------------|-------------------------------|-----|\n| [Souverein et al. 2022](https://academic.oup.com/ofid/article/9/7/ofac223/6576478#:~:text=26.3%20(IQR%2C%205.7).-,Association%20Between%20Cp%20Value%20and%20Hospital%20Admission,-Of%20the%2020)  | 19897 outpatients, 310 inpatients | OP/NP  |26.3 (5.6) | 25.0 (5.2) | 1.3 |\n| [Knudtzen et al. 2021](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0258421#:~:text=SARS%2DCoV%2D2%20PCR%20Cq%2Dvalue%20as%20a%20marker%20for%20hospital%20admission) | 87 outpatients, 82 inpatients | 13 OP/NP, 130 OP, 26 sputum | 26.9 (7.7) | 24.6 (6.7)| 2.3|\n| [Babiker et al. 2020](https://journals.asm.org/doi/10.1128/jcm.02142-20) | 10 outpatients, 34 inpatients | NP | 24.25 (7.8) | 25.35 (5.8) | -1.1|\n| [Rodriguez et al. 2021](https://journals.plos.org/plospathogens/article?id=10.1371/journal.ppat.1009416#sec010) | 42 outpatients, 17 inpatients | NP | 30.0 (7.0) | 24.0 (6.8) | 6 |\n: Table 1: Studies that sampled both inpatients and outpatients (includes two of our target studies)\n\n### Disease onset\n\nThe lower viral load in inpatients is most likely caused by them entering the hospital later. Indeed, as we see in Knudtzen et al. 2021 which ran a prospective cohort study on a inpatient and outpatient cohort, the inpatient samples were collected later.\n\n\n\n![Figure from [Knudtzen et al. 2021](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0258421): Relationship between days since symptom onset and viral load.](img/knudtzen-et-al-2021.png)\n\n\nTwo other studies also provide data on viral load in relation to disease onset: Bullard et al. 2020 and He et al. 2020.\n\n| Study Name| No. of patients | Swab type| Patient type |\n|-----------|-----------------|----------|--------------|\n| [Knudtzen et al. 2021](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0258421) | 169 | NP and/or OP, Saliva | 87 outpatients, 82 stationary |\n| [Bullard et al. 2020](https://academic.oup.com/cid/article/71/10/2663/5842165) | 90 | NP or endotracheal (ETT) | Samples at a public health lab |\n| [He et al. 2020](https://www.nature.com/articles/s41591-020-0869-5) | 94 | throat | inpatients (none were severe or critically ill) |\n: Table 2: Studies that provide information on viral load in relation to disease onset.\n\nLooking at this data there is a fairly clear relationship between time and lower viral load. (Need to account for the outlier in Knudtzen et al. inpatients where a couple of patients that were tested very late showed lot CT values)\n\n::: {#64e1a823 .cell execution_count=17}\n``` {.python .cell-code}\ndf_knudtzen_ct_days = pd.read_csv('data/knudtzen2021_ct_days.tsv', sep='\\t', skiprows=1)\ndf_bullard_ct_days = pd.read_csv('data/bullard2021_ct_days.tsv', sep='\\t', skiprows=1)\ndf_he_ct_days = pd.read_csv('data/he2020_ct_days.tsv', sep='\\t', skiprows=1)\n\ndf_knudtzen_outpatients = df_knudtzen_ct_days[df_knudtzen_ct_days['Patient Status'] == 'Outpatient']\ndf_knudtzen_inpatients =  df_knudtzen_ct_days[df_knudtzen_ct_days['Patient Status'] == 'Inpatient']\n\n# Round \"Day\" column to nearest full number for all dataframes\ndf_knudtzen_outpatients['Day'] = df_knudtzen_outpatients['Day'].round()\ndf_knudtzen_inpatients['Day'] = df_knudtzen_inpatients['Day'].round()\ndf_bullard_ct_days['Day'] = df_bullard_ct_days['Day'].round()\ndf_he_ct_days['Day'] = df_he_ct_days['Day'].round()\n\n# For each dataframe, reset CT to be the average CT for each Day.\n# For each dataframe, reset CT to be the average CT for each Day.\ndf_knudtzen_outpatients = df_knudtzen_outpatients.groupby('Day', as_index=False).agg({'CT': 'mean'})\ndf_knudtzen_inpatients = df_knudtzen_inpatients.groupby('Day', as_index=False).agg({'CT': 'mean'})\ndf_bullard_ct_days = df_bullard_ct_days.groupby('Day', as_index=False).agg({'Median CT': 'mean'}).rename(columns={'Median CT': 'CT'})\ndf_he_ct_days = df_he_ct_days.groupby('Day', as_index=False).agg({'CT': 'mean'})\n\ndf_knudtzen_outpatients['CT_rolling_mean'] = df_knudtzen_outpatients.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\ndf_knudtzen_inpatients['CT_rolling_mean'] = df_knudtzen_inpatients.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\ndf_bullard_ct_days['CT_rolling_mean'] = df_bullard_ct_days.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\ndf_he_ct_days['CT_rolling_mean'] = df_he_ct_days.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\n\ncombined_df = pd.concat([\n    df_knudtzen_inpatients.assign(Study='Knudtzen et al. 2021 | Inpatients'),\n    df_knudtzen_outpatients.assign(Study='Knudtzen et al. 2021 | Outpatients'),\n    df_bullard_ct_days.assign(Study='Bullard et al. 2020'),\n    df_he_ct_days.assign(Study='He et al. 2020')\n])\n\nfig, ax = plt.subplots(figsize=(10, 6),dpi=600)\nsns.lineplot(data=combined_df, x='Day', y='CT_rolling_mean', hue='Study', ax=ax)\n\nax.set_xlabel('Days since symptom onset')\nax.set_ylabel('qPCR CT Value (3-day rolling average)')\n\nax.legend(title='', loc='lower center', bbox_to_anchor=(0.5, -0.3), ncol=2)\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 9: qPCR CT Value vs Days since symptom onset** Data is taken from Knudtzen et al. 2021, Bullard et al. 2020, and He et al. 2020.](index_files/figure-html/cell-18-output-1.png){}\n:::\n:::\n\n\n### Asymptomatic individuals\n\nFinally, a further difference between our target studies and the ultimate sampling program we are considering is that sampled individuals would be asymptomatic. We identified four studies that researched this questions. Information on these papers can be found in Appendix 2.\n\n| Study | Sample size | Sample type | Symptomatic CT Value (median, IQR) | Asymptomatic CT Value (median, IQR) |\n|----------------------|----------------------------|----------------------|-------------------------------|-------------------------------|\n| [Hall et al. 2022](https://doi.org/10.1371/journal.pone.0270694) | 357 asymptomatic, 1276 symptomatic or pre-symptomatic | Anterior nasal swab | N1: 21.8 (17.2-29.4), N2: 21.4 (17.3-28.9) | N1: 29.9 (23.6-35.5), N2: 30.0 (23.1-35.7) |\n| [Long et al. 2020](https://doi.org/10.1038/s41591-020-0965-6) | 37 asymptomatic, 37 symptomatic | NP | ORF1ab: 31.7 (30.3-35.1), N: 33.5 (31.3-37.2) | ORF1ab: 32.8 (30.9-35.8), N: 32.6 (29.5-34.6) |\n| [Lee et al. 2022](https://jamanetwork.com/journals/jamainternalmedicine/fullarticle/2769235) | 89 asymptomatic, 214 symptomatic | NP, OP, sputum | no raw data | no raw data |\n| [Zhou et al. 2020](https://doi.org/10.1016/j.ijid.2020.05.030) | 9 asymptomatic, 22 pre-symptomatic | NP | 34.5 (32.2-37.0) | 39.0 (37.5-39.5) |\n: Table 2: Viral load in symptomatic and asymptomatic individuals. Lee et al 2022 provides no raw data but noted that there was no significant difference between symptomatic and asympatomic individuals.\n\n### A BOTEC for the sensitivity pooled swab sampling program\n\nWe can use the factors above to adjust the data in our target datasets. Note that this very much has the status of a BOTEC and would require more sophisticated modelling for us to put much faith in it. Anyway, let's for now:\n\n1. Drop all samples that are from ICU or ventilator patients.\n2. Adjust nasopharyngeal and oropharyngeal swabs by the adjustment factors discussed earlier (+1.82 for NP, -1 for OP samples)\n3. Adjust inpatient samples by the observed difference to outpatient samples (-2.1) #TODISCUSS, this is clearly wrong.\n4. Adjust all samples to resemble asymptomatics (+4.3)\n5. #TODO Adjust for days.\n\n::: {#0ac5f864 .cell execution_count=18}\n``` {.python .cell-code}\ndf_np_babiker, df_np_rodriguez, df_op_lu, df_np_mostafa = return_studies()\n\ndf_np_babiker['Study'] = 'Babiker et al. 2020'\ndf_np_rodriguez['Study'] = 'Rodriguez et al. 2021'\ndf_op_lu['Study'] = 'Lu et al. 2021'\ndf_np_mostafa['Study'] = 'Mostafa et al. 2020'\ncomposite_df = pd.concat([df_np_babiker, df_np_rodriguez, df_op_lu, df_np_mostafa], ignore_index=True)\ncomposite_df = composite_df[composite_df['patient_status'].isin(['Inpatient', 'Outpatient'])]\ninpatient_adjustment_factor = -2.1\nasymptomatic_adjustment_factor = 4.3\nnp_adjustment_factor = 1\nop_adjustment_factor = -1\n\n# Apply the adjustment to Inpatient samples\ncomposite_df[\"adjusted_scv2_ct\"] = composite_df[\"scv2_ct\"]\ncomposite_df.loc[composite_df['patient_status'] == 'Inpatient', 'adjusted_scv2_ct'] += inpatient_adjustment_factor\n\ncomposite_df[\"adjusted_scv2_ct\"] = composite_df[\"adjusted_scv2_ct\"] + asymptomatic_adjustment_factor\n\ncomposite_df.loc[composite_df['swab_type'] == 'NP', 'adjusted_scv2_ct'] += np_adjustment_factor\ncomposite_df.loc[composite_df['swab_type'] == 'OP', 'adjusted_scv2_ct'] += op_adjustment_factor\n\ncomposite_df[\"scv2_ra_logged\"] = composite_df[\"scv2_ra\"].apply(np.log10)\n\nresult = linregress(composite_df['scv2_ct'], composite_df['scv2_ra_logged'])\n\n\ncomposite_df[\"adjusted_scv2_ra_logged\"] = result.intercept + result.slope * composite_df[\"adjusted_scv2_ct\"]\n\nfig, axs = plt.subplots(2,1,figsize=(8,6), sharey=True, dpi=600)\nfig.subplots_adjust(hspace=0.5)  # Add vertical space between axs\n\n\ncomposite_df[\"adjusted_scv2_ra_logged\"] = result.intercept + result.slope * composite_df[\"adjusted_scv2_ct\"]\ncomposite_df[\"adjusted_scv2_ra_logged_stderr\"] = np.sqrt(\n    result.intercept_stderr**2 + (result.stderr * composite_df[\"adjusted_scv2_ct\"])**2\n)\n\n# Generate random noise based on the standard errors\nnp.random.seed(42)  # Set a random seed for reproducibility\nnoise = np.random.normal(loc=0, scale=composite_df[\"adjusted_scv2_ra_logged_stderr\"])\n\n# Add the noise to the adjusted log relative abundance values\ncomposite_df[\"adjusted_scv2_ra_logged_with_noise\"] = composite_df[\"adjusted_scv2_ra_logged\"] + noise\n\n# Create scatter plots\nsns.scatterplot(data=composite_df, y='scv2_ra_logged', x='scv2_ct', palette=sns_default_colors, s=70, hue='Study', style='Study', ax=axs[0])\nsns.scatterplot(data=composite_df, y='adjusted_scv2_ra_logged_with_noise', x='adjusted_scv2_ct', palette=sns_default_colors, s=70, hue='Study', style='Study', ax=axs[1])\ntitles = [\"Original values\", \"Adjusted CT and extrapolated RA value\"]\nfor ax, title in zip(axs, titles):\n    #ax.set_yscale('log')\n    ax.set_xlabel('')\n    ax.set_title(title)\n    ax.legend([], [], frameon=False)\n    #ax.set_xlim(x_lim)\n    #y_lim_adjusted = (y_lim[0], y_lim[1] * 1.05)  # Adjust upper limit to ensure top dot is fully displayed\n    #ax.set_ylim(y_lim_adjusted)\n    ax.invert_xaxis()\n    ax.spines['right'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.tick_params(axis='y', which='minor', left=False, right=False, labelleft=True)\n    ax.set_ylabel('Relative Abundance')\n    ax.set_xlim(40,15)\n    for x in np.arange(15, 40, 5):\n        ax.axvline(x=x, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n    for y in range(-7, 1, 1):\n\n        ax.axhline(y=y, color='grey', linestyle='--', alpha=0.5, linewidth=0.5)\n\naxs[1].legend(title='', loc='lower center', bbox_to_anchor=(0.5, -0.6), ncol=2, frameon=False)\n\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 10: Data extrapolated to asymptomatic individuals, sampled with anterior nasal swabs**](index_files/figure-html/cell-19-output-1.png){}\n:::\n:::\n\n\nHow does this compare to our initial estimate regarding sensitivity? We get worse sensitivity, but nothing that's too bad. At 200 swabs, the composite dataset gives us a cumulative incidence of 1%, and at 400 swabs one of 0.7%. This compares to 0.5, and 0.3% for Lu et al. 2021.\n\n\n\n# Appendix\n\n##### Appendix 1: Adjusting for swab type\n\n| Study Name| No. of positive pairs | NP CT - Nasal CT| Collection method |\n|-----------|-----------------------|-------------------|-----------------|\n| [Patriquin et al. 2022](https://journals.asm.org/doi/full/10.1128/spectrum.02455-21) | 70 | -3| Both professionally collected|\n| [McCulloch et al. 2020](https://jamanetwork.com/journals/jamanetworkopen/article-abstract/2768535) | 21 | -1.6| Nasal was self-collected, NP was professionally collected |\n| [Pere et al 2020](https://journals.asm.org/doi/full/10.1128/jcm.00721-20) | 23 |-1|Both professionally collected|\n| [Kojima et al. 2020](https://academic.oup.com/cid/article/73/9/e3106/5930814?login=false) | 30  |-4|Nasal was self-collected, NP was professionally collected|\n| [Tu et al. 2020](https://www.nejm.org/doi/full/10.1056/NEJMc2016321) | 46 |0| Nasal was self-collected, NP was professionally collected|\n: Table S1: Nasal swabs vs nasopharyngeal swabs.\n\n| Study Name| No. of positive pairs | CT/Genome Copy Number difference[^2] | Collection method | Pathogen |\n|-----------|-----------------------|---------------------------------------|-------------------|----------|\n| [Berenger et al. 2020](https://www.medrxiv.org/content/10.1101/2020.05.05.20084889v1.full) | 19 | 1 | Both professionally collected| SARS-CoV-2 |\n| [Goodall et al. 2022](https://journals.asm.org/doi/10.1128/spectrum.00217-22#core-B16) | 58 | 0.95 | Both self-collected | SARS-CoV-2 |\n| [Leung et al. 2022](https://www.nature.com/articles/s41591-020-0843-2)| 11, 33, 37 | X, Y, Z | Both self-collected | HCoV, Influenza, Rhinovirus |\n: Table S2: Oropharyngeal swabs vs nasal swabs.\n\n\n[^2]: qPCr differences are computed by subtracting the CT value of OP swab mean with the one of Nasal swabs. Genome copy number differences are computed by subtracting the genome copy number log of OP swabs from the genome copy number log of Nasal swabs.\n##### Appendix 2: Adjusting for days since symptom onset\n\n\n| Study Name| No. of patients | Swab type| Patient type |\n|-----------|-----------------|----------|--------------|\n| [Knudtzen et al. 2021](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0258421) | 169 | NP and/or OP, Saliva | 87 outpatients, 82 stationary |\n| [Bullard et al. 2020](https://academic.oup.com/cid/article/71/10/2663/5842165) | 90 | NP or endotracheal (ETT) | Samples at a public health lab |\n| [He et al. 2020](https://www.nature.com/articles/s41591-020-0869-5) | 94 | throat | inpatients (none were severe or critically ill) |\n: Table S3: Days since symptom onset.\n\nThe data from these different studies is not available, but we can extract it from the relevant figures:\n\n:::{.column-page layout-ncol=3}\n\n![He et al. 2020](img/he-et-al-2020.png)\n\n![Bullard et al. 2020](img/bullard-et-al-2020.png)\n\n![Knudtzen et al. 2021](img/knudtzen-et-al-2021.png)\n\nFigure X: Relationship between days since symptom onset and viral load.\n:::\n\n::: {#d88f949e .cell execution_count=20}\n``` {.python .cell-code}\ndf_knudtzen_ct_days = pd.read_csv('data/knudtzen2021_ct_days.tsv', sep='\\t', skiprows=1)\ndf_bullard_ct_days = pd.read_csv('data/bullard2021_ct_days.tsv', sep='\\t', skiprows=1)\ndf_he_ct_days = pd.read_csv('data/he2020_ct_days.tsv', sep='\\t', skiprows=1)\n\ndf_knudtzen_outpatients = df_knudtzen_ct_days[df_knudtzen_ct_days['Patient Status'] == 'Outpatient']\ndf_knudtzen_inpatients =  df_knudtzen_ct_days[df_knudtzen_ct_days['Patient Status'] == 'Inpatient']\n\n# Round \"Day\" column to nearest full number for all dataframes\ndf_knudtzen_outpatients['Day'] = df_knudtzen_outpatients['Day'].round()\ndf_knudtzen_inpatients['Day'] = df_knudtzen_inpatients['Day'].round()\ndf_bullard_ct_days['Day'] = df_bullard_ct_days['Day'].round()\ndf_he_ct_days['Day'] = df_he_ct_days['Day'].round()\n\n# For each dataframe, reset CT to be the average CT for each Day.\n# For each dataframe, reset CT to be the average CT for each Day.\ndf_knudtzen_outpatients = df_knudtzen_outpatients.groupby('Day', as_index=False).agg({'CT': 'mean'})\ndf_knudtzen_inpatients = df_knudtzen_inpatients.groupby('Day', as_index=False).agg({'CT': 'mean'})\ndf_bullard_ct_days = df_bullard_ct_days.groupby('Day', as_index=False).agg({'Median CT': 'mean'}).rename(columns={'Median CT': 'CT'})\ndf_he_ct_days = df_he_ct_days.groupby('Day', as_index=False).agg({'CT': 'mean'})\n\ndf_knudtzen_outpatients['CT_rolling_mean'] = df_knudtzen_outpatients.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\ndf_knudtzen_inpatients['CT_rolling_mean'] = df_knudtzen_inpatients.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\ndf_bullard_ct_days['CT_rolling_mean'] = df_bullard_ct_days.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\ndf_he_ct_days['CT_rolling_mean'] = df_he_ct_days.groupby('Day')['CT'].rolling(window=5, min_periods=1, center=True).mean().reset_index(drop=True)\n\ncombined_df = pd.concat([\n    df_knudtzen_inpatients.assign(Study='Knudtzen et al. 2021 | Inpatients'),\n    df_knudtzen_outpatients.assign(Study='Knudtzen et al. 2021 | Outpatients'),\n    df_bullard_ct_days.assign(Study='Bullard et al. 2020'),\n    df_he_ct_days.assign(Study='He et al. 2020')\n])\n\nfig, ax = plt.subplots(figsize=(10, 6),dpi=600)\nsns.lineplot(data=combined_df, x='Day', y='CT_rolling_mean', hue='Study', ax=ax)\n\nax.set_xlabel('Days since symptom onset')\nax.set_ylabel('qPCR CT Value (3-day rolling average)')\nax.set_title('qPCR CT Value vs Days since symptom onset')\nax.legend(title='', loc='lower center', bbox_to_anchor=(0.5, -0.3), ncol=2)\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-21-output-1.png){}\n:::\n:::\n\n\n##### Appendix 3: Inpatients vs Outpatients\n\nThere are two studies that have done this and looked at the average qPCR cycle threshold (CT) values in swabs of inpatients and outpatients. Souverein et al. 2022 looked at a dataset of 20207 positive COVID-19 tests that were all performed at two public health testing facilities in the Netherlands. Patients were subsequently classified as inpatients or outpatients if they got admitted to a hospital within 30 days of their initial test. The results from this study are thus somewhat imperfect: They do not measure the CT value of current in-/outpatients but rather show the CT value difference between patients who went on to be hospitalized or not. Still, based on this data the CT value difference between individuals who remained outpatients and individuals who went on to become inpatients was -1.3 (25.0-26.3), where inpatients had lower viral loads (and thus a higher CT value). Knudtzen et al. 2021 more closely resembles what we are looking for. Here, researchers identified the qPCR CT values of outpatients (n=87) through an outpatient cohort study and the values of hospitalized patients (n=82) through medical records. The CT value difference was -2.3 (24.6 - 26.9) again in favor of outpatients. Again there some limitations to study because researchers used [three different qPCR assays](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0258421#:~:text=SARS%2DCoV%2D2%20detection%20was%20established%20on%20three%20different%20analysis%20platforms%E2%80%94the%20fully%20automated%20high%20throughput%20Cobas%206800%20(Roche)%2C%20the%20commercially%20available%20kit%20RealStar%C2%AE%20SARS%2DCoV%2D2%20RT%2DPCR%20kit%201.0%20(Altona%20Diagnostics)%20and%20a%20laboratory%20developed%20real%2Dtime%20(RT)%2DPCR.), and there is no data on patient/qPCR matches. Finally, two of the MGS studies also included both inpatients and outpatients at meaningful numbers (Babiker at al. 2020, Rodriguez et al. 2021). Babiker et al. 2020 included 10 outpatients and  34 inpatients. All nasopharyngeal swab samples were analyzed with qPCR by the researchers themselves, presumably using the same protocol for all samples. Looking at this data we find that CT values in inpatients are 1.15 points lower (25.35-24.25). For Rodriguez et al. 2021, both outpatients (n=42) and inpatients (n=17) were tested with the same qPCR assay (RealStar SARS-CoV-2 RT-PCR Kit, Altona Diagnostics, Hamburg, Germany). Here the average CT value in inpatients was 6 CTs higher  in outpatients (24-30).\n\nWithout weighing the studies the inpatients have an average qPCR result that is **~2.1** CT values higher.\n\n| Study                | Sample size                | Sample type          | Inpatient CT (median, IQR)           | Outpatient CT (median, IQR)                |\n|----------------------|----------------------------|----------------------|-------------------------------|-------------------------------|\n| [Souverein et al. 2022](https://academic.oup.com/ofid/article/9/7/ofac223/6576478#:~:text=26.3%20(IQR%2C%205.7).-,Association%20Between%20Cp%20Value%20and%20Hospital%20Admission,-Of%20the%2020)  | 19897 outpatients, 310 inpatients | OP/NP  |     26.3 (5.6)                   | 25.0 (5.2) |\n| [Knudtzen et al. 2021](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0258421#:~:text=SARS%2DCoV%2D2%20PCR%20Cq%2Dvalue%20as%20a%20marker%20for%20hospital%20admission) | 87 outpatients, 82 inpatients | 13 OP/NP, 130 OP, 26 sputum | 26.9 (7.7) | 24.6 (6.7)|\n| [Babiker et al. 2020](https://journals.asm.org/doi/10.1128/jcm.02142-20) | 10 outpatients, 34 inpatients | NP | 24.25 (7.8) | 25.35 (5.8) |\n| [Rodriguez et al. 2021](https://journals.plos.org/plospathogens/article?id=10.1371/journal.ppat.1009416#sec010) | 42 outpatients, 17 inpatients | NP | 30.0 (7.0) | 24.0 (6.8) |\n: Table S4: Inpatient vs Outpatient data.\n\n\n##### Appendix 4: Adjusting for asymptomatic individuals\n\nOnce we've adusted for the inpatient population we still need to account for individuals being symptomatic. To make this symptomatic to asymptomatic adjustement, we found four different studies. Hall et al. 2022 looked at the results of a university testing program that tracked symptoms upon taking the test and thereafter. The median CT of asymptomatic individuals was around 8 points higher, with symptomatic patients showing a CT value of 21.8 (N1) and 21.4 (N2) compared to 29.9 (N1) and 30.0 (N2) for asymptomatics. Long et al. 2020 compared 37 asymptomatic individuals to 37 symptomatic patients and found no clear difference in median CT values between the two groups, with the median symptomatic CT value for ORF1ab being 1 point lower and the median value for N being 0.9 higher compared to asymptmatics. Lee et al. 2021 studied patients in an isolation facility. They do not provide raw data or median values, but report there was no qPCR CT value difference between symptomatic and asymptomatic patients in their study. Let's treat this as zero for now (#FIXME). Finally, Zhou et al. 2020 investigated 31 patients who were asymptomatic on admission, of which 22 developed symptoms later (pre-symptomatic) and 9 remained asymptomatic. Here the median CT of symptomatics was 4.5 points lower.\n\nAgain, without weighing the studies the average CT value difference of symptomatic or pre-symptomatic is **~4.3** CT values lower than that of individuals who remain asymptomatic.\n\n| Study | Sample size | Sample type | Symptomatic CT Value (median, IQR) | Asymptomatic CT Value (median, IQR) |\n|----------------------|----------------------------|----------------------|-------------------------------|-------------------------------|\n| [Hall et al. 2022](https://doi.org/10.1371/journal.pone.0270694) | 357 asymptomatic, 1276 symptomatic or pre-symptomatic | Anterior nasal swab | N1: 21.8 (17.2-29.4), N2: 21.4 (17.3-28.9) | N1: 29.9 (23.6-35.5), N2: 30.0 (23.1-35.7) |\n| [Long et al. 2020](https://doi.org/10.1038/s41591-020-0965-6) | 37 asymptomatic, 37 symptomatic | NP | ORF1ab: 31.7 (30.3-35.1), N: 33.5 (31.3-37.2) | ORF1ab: 32.8 (30.9-35.8), N: 32.6 (29.5-34.6) |\n| [Lee et al. 2022](https://jamanetwork.com/journals/jamainternalmedicine/fullarticle/2769235) | 89 asymptomatic, 214 symptomatic | NP, OP, sputum | no raw data | no raw data |\n| [Zhou et al. 2020](https://doi.org/10.1016/j.ijid.2020.05.030) | 9 asymptomatic, 22 pre-symptomatic | NP | 34.5 (32.2-37.0) | 39.0 (37.5-39.5) |\n: Table S5: Days since symptom onset.\n\n",
    "supporting": [
      "index_files/figure-html"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}
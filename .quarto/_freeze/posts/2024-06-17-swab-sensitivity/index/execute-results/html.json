{
  "hash": "b2433da2fce3522e43844cc4253847f3",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Investigating the sensitivity of pooled swab sampling for pathogen early detection\nsubtitle: Sequencing swabs in non-hospital settings could offer cheap and pathogen-agnostic early detection\nauthor:\n  - Simon Grimm\n  - Will Bradshaw\ndate: '2024-06-18'\ntoc: true\nformat:\n  html:\n    code-fold: true\n    code-tools: true\n    code-link: true\n    df-print: paged\neditor: visual\n---\n\n\n::: {#define-functions .cell execution_count=2}\n``` {.python .cell-code}\nSWAB_SAMPLE_SIZES = [50, 100, 200]\n\n\nWW_STUDY_TITLES = [\"Rothman et al. 2021\", \"Crits-Christoph et al. 2021\"]\n\n\ndef logit(x):\n    return np.log(x / (1 - x))\n\n\ndef logistic(x):\n    return 1 / (1 + np.exp(-x))\n\n\ndef return_studies():\n    df_op_lu = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/lu_throat_ct_mgs.tsv\", sep=\"\\t\", skiprows=1)\n    df_op_lu.rename(\n        columns={\"SCV-2 Relative Abundance\": \"scv2_ra\", \"Ct value\": \"scv2_ct\"},\n        inplace=True,\n    )\n    df_op_lu[[\"patient_status\", \"swab_type\", \"Study\"]] = [\n        \"Inpatient\",\n        \"op\",\n        \"Lu et al. 2021\",\n    ]\n\n    df_np_rodriguez = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/rodriguez_np_ct_mgs.csv\", sep=\";\")\n    rodriguez_patient_status_dict = {\n        \"Hospit\": \"Inpatient\",\n        \"Out_Patient\": \"Outpatient\",\n        \"Intensive_Care\": \"ICU\",\n    }\n    df_np_rodriguez[\"patient_status\"] = df_np_rodriguez[\"Group\"].replace(\n        rodriguez_patient_status_dict\n    )\n    df_np_rodriguez[\"scv2_ra\"] = (\n        df_np_rodriguez[\"Reads_2019_CoV\"] / df_np_rodriguez[\"Reads_Total\"]\n    )\n    df_np_rodriguez = df_np_rodriguez[df_np_rodriguez[\"scv2_ra\"] != 0]\n    df_np_rodriguez.rename(columns={\"CoV_Ct_number\": \"scv2_ct\"}, inplace=True)\n    df_np_rodriguez[[\"swab_type\", \"Study\"]] = [\"np\", \"Rodriguez et al. 2021\"]\n\n    df_np_babiker = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/babiker_np_ct_mgs.tsv\", sep=\"\\t\", skiprows=1)\n    df_np_babiker.rename(\n        columns={\n            \"SARS-CoV-2 RT-PCR Ct\": \"scv2_ct\",\n            \"SARS-CoV-2 RA\": \"scv2_ra\",\n            \"Inpatient/ED vs. Outpatient\": \"patient_status\",\n        },\n        inplace=True,\n    )\n    df_np_babiker[\"scv2_ct\"] = (\n        df_np_babiker[\"scv2_ct\"].replace(\",\", \".\", regex=True).astype(float)\n    )\n    df_np_babiker[\"patient_status\"] = df_np_babiker[\"patient_status\"].apply(\n        lambda x: x if x in [\"Inpatient\", \"Outpatient\"] else \"Unknown\"\n    )\n    # The data uses . to represent missing data. Set this column to integers, while at the same time mapping missing data to NA.\n    df_np_babiker[\"days_from_onset\"] = (\n        df_np_babiker[\"Day of Testing Relative to Symptom Onset\"]\n        .replace(\".\", \"-1\")\n        .astype(int)\n        .replace(-1, \"NA\")\n    )\n    df_np_babiker[[\"swab_type\", \"Study\"]] = [\"np\", \"Babiker et al. 2020\"]\n\n    df_np_mostafa = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/2024-05-30-mostafa-raw-ra-ct.tsv\", sep=\"\\t\")\n    mostafa_severity_dict = {\n        1: \"Required\\nventilator\",\n        2: \"ICU\",\n        3: \"Inpatient\",\n        4: \"Outpatient\",\n        0: \"Unknown\",\n    }\n    df_np_mostafa.rename(\n        columns={\n            \"SARS-CoV-2 RT-PCR Ct value\": \"scv2_ct\",\n            \"CosmosID Proportion Mapped to SARS-CoV-2\": \"scv2_ra\",\n        },\n        inplace=True,\n    )\n    df_np_mostafa[\"Severity index\"] = df_np_mostafa[\"Severity index\"].replace(\"–\", 0)\n    df_np_mostafa[\"patient_status\"] = (\n        df_np_mostafa[\"Severity index\"].astype(int).replace(mostafa_severity_dict)\n    )\n    # There is no information of why some patients only have \"<7\" as their days from onset. We set it to 3.5 (the average of 1-6 days.)\n    df_np_mostafa[\"days_from_onset\"] = df_np_mostafa[\"No. of days from onset\"].replace(\n        {\"–\": \"NA\", \"<7\": \"3.5\"}\n    )\n    # Drop samples unless we have both qPCR and MGS detection\n    df_np_mostafa = df_np_mostafa[df_np_mostafa[\"COVID-19-positive\"] == True]\n    df_np_mostafa = df_np_mostafa[df_np_mostafa[\"scv2_ct\"] != \"–\"]\n    df_np_mostafa[\"scv2_ct\"] = df_np_mostafa[\"scv2_ct\"].astype(float)\n    df_np_mostafa = df_np_mostafa[df_np_mostafa[\"scv2_ra\"] != 0]\n    df_np_mostafa[\"scv2_ra\"] = df_np_mostafa[\"scv2_ra\"].astype(float)\n    df_np_mostafa[[\"swab_type\", \"Study\"]] = [\"np\", \"Mostafa et al. 2020\"]\n    # TODO: Matching df names and study titles.\n\n    study_dfs = {\n        \"Lu et al. 2021\": df_op_lu,\n        \"Babiker et al. 2020\": df_np_babiker,\n        \"Mostafa et al. 2020\": df_np_mostafa,\n        \"Rodriguez et al. 2021\": df_np_rodriguez,\n    }\n    return study_dfs\n\n\n\ndef return_study_ras():\n    study_dfs = return_studies().values()\n    # TODO:NAs should already have been dropped in the code above.\n    study_ras = [df[\"scv2_ra\"].dropna().tolist() for df in study_dfs]\n    return study_ras\n\ndef return_composite_ras():\n    study_ras = return_study_ras()\n    composite_swab_ras = sum(study_ras, [])\n    return composite_swab_ras\n\n\ndef return_adjusted_composite_ras():\n    study_dfs = return_studies().values()\n\n    composite_df = pd.concat(study_dfs)\n\n    composite_df = composite_df[\n        composite_df[\"patient_status\"].isin([\"Inpatient\", \"Outpatient\"])\n    ]\n    # TODO: Use named tuples here.\n    symptom_status_dfs = adjust_cts(composite_df)\n\n    df_asymptomatic = symptom_status_dfs[\"Asymptomatic\"]\n    df_symptomatic = symptom_status_dfs[\"Symptomatic\"]\n\n    df_asymptomatic_mgs_df = adjust_rel_abun(df_asymptomatic)\n    df_symptomatic_mgs_df = adjust_rel_abun(df_symptomatic)\n\n    asymptomatic_ras = df_asymptomatic_mgs_df[\"adjusted_scv2_ra\"].tolist()\n    symptomatic_ras = df_symptomatic_mgs_df[\"adjusted_scv2_ra\"].tolist()\n\n    return asymptomatic_ras, symptomatic_ras\n\ndef return_study_p2ra():\n    study_ras = return_study_ras()\n    study_p2ra_df = return_swab_p2ra(SWAB_STUDY_TITLES, study_ras)\n    return study_p2ra_df\n\ndef return_composite_p2ra():\n    composite_ras = return_composite_ras()\n    composite_p2ra_df = return_swab_p2ra([\"Original Composite Data\"], [composite_ras])\n    return composite_p2ra_df\n\ndef return_adjusted_composite_p2ra():\n    ASYMPTOMATIC_SHARE = 0.35\n    # TODO: Work with a named tuple here.\n    asymptomatic_ras, symptomatic_ras = return_adjusted_composite_ras()\n\n    asymptomatic_p2ra_df = return_swab_p2ra(\n        [\"Adjusted\\nComposite Data\"], [asymptomatic_ras]\n    )\n    symptomatic_p2ra_df = return_swab_p2ra(\n        [\"Adjusted\\nComposite Data\"], [symptomatic_ras]\n    )\n\n    asymptomatics = asymptomatic_p2ra_df.sample(\n        frac=ASYMPTOMATIC_SHARE, random_state=42\n    )\n    symptomatics = symptomatic_p2ra_df.sample(\n        frac=1 - ASYMPTOMATIC_SHARE, random_state=42\n    )\n\n    composite_adjusted_p2ra_df = pd.concat(\n        [asymptomatics, symptomatics], ignore_index=True\n    )\n    return composite_adjusted_p2ra_df\n\n\n\ndef adjust_cts(df):\n    # https://doi.org/10.1371/journal.pone.0270694\n    long_2020_asymptomatic_delta = 0 # \"The initial Ct values for 37 asymptomatic individuals and 37 symptomatic patients appeared similar\" https://www.nature.com/articles/s41591-020-0965-6\n    lee_2020_asymptomatic_delta = 0 # \"There were no significant differences in Ct values between asymptomatic and symptomatic (including presymptomatic) patients.\" 10.1001/jamainternmed.2020.3862\n    yang_2023_asymptomatic_delta = 0.99 # Extracted from supplement figure 4D https://doi.org/10.1016/S2666-5247(23)00139-8\n\n\n    hall_asymptomatic_ct_median = 29.9\n    hall_symptomatic_ct_median = 21.8\n    hall_asymptomatic_delta = hall_asymptomatic_ct_median - hall_symptomatic_ct_median\n    ASYMPTOMATIC_ADJUSTMENT_FACTOR = (hall_asymptomatic_delta + long_2020_asymptomatic_delta + lee_2020_asymptomatic_delta + yang_2023_asymptomatic_delta) / 4\n    print(ASYMPTOMATIC_ADJUSTMENT_FACTOR)\n\n    # TODO: do calculation of these factors in the code.\n\n    NP_ADJUSTMENT_FACTOR = 1.43\n    OP_ADJUSTMENT_FACTOR = -0.92\n    df[\"adjusted_scv2_ct\"] = df[\"scv2_ct\"]\n    df.loc[df[\"swab_type\"] == \"np\", \"adjusted_scv2_ct\"] += NP_ADJUSTMENT_FACTOR\n    df.loc[df[\"swab_type\"] == \"op\", \"adjusted_scv2_ct\"] += OP_ADJUSTMENT_FACTOR\n    df_symptomatic = df.copy()\n    df_asymptomatic = df.copy()\n    df_asymptomatic[\"adjusted_scv2_ct\"] += ASYMPTOMATIC_ADJUSTMENT_FACTOR\n\n    symptom_status_dfs = {\n        \"Asymptomatic\": df_asymptomatic,\n        \"Symptomatic\": df_symptomatic\n    }\n\n    return symptom_status_dfs\n\n\ndef adjust_rel_abun(df):\n\n    study_dfs = return_studies().values()\n\n    composite_df = pd.concat(study_dfs)\n    composite_df[\"scv2_ra_logged\"] = composite_df[\"scv2_ra\"].apply(np.log10)\n\n    slope, intercept, r_value, p_value, std_err = linregress(\n        composite_df[\"scv2_ct\"], composite_df[\"scv2_ra_logged\"]\n    )\n    df[\"adjusted_scv2_ra_logged\"] = intercept + slope * df[\"adjusted_scv2_ct\"]\n    # TODO: Double check if the math below is correct.\n    df[\"adjusted_scv2_ra_logged_stderr\"] = np.sqrt(\n        std_err**2 + (std_err * df[\"adjusted_scv2_ct\"]) ** 2\n    )\n\n    noise = np.random.normal(loc=0, scale=df[\"adjusted_scv2_ra_logged_stderr\"])\n    df[\"adjusted_scv2_ra_logged_with_noise\"] = df[\"adjusted_scv2_ra_logged\"] + noise\n    df[\"adjusted_scv2_ra\"] = 10 ** df[\"adjusted_scv2_ra_logged_with_noise\"]\n\n    return df\n\n\ndef return_swab_p2ra(subset_titles, ra_lists):\n    swab_df = pd.DataFrame()\n\n    for subset, ras in zip(subset_titles, ra_lists):\n\n        samples = return_logit_normal_samples(ras)\n\n        df = simulate_p2ra_many(samples, SWAB_SAMPLE_SIZES, n_simulations=10000)\n\n        df[\"Subset\"] = subset\n        swab_df = pd.concat(\n            [\n                swab_df,\n                df.melt(\n                    id_vars=\"Subset\",\n                    value_vars=SWAB_SAMPLE_SIZES,\n                    var_name=\"Sample Size\",\n                    value_name=\"Relative Abundance\",\n                ),\n            ]\n        )\n\n    return swab_df\n\ndef return_logit_normal_samples(ras):\n    ra_values = np.array(ras)\n    logit_ra_values = logit(ra_values)\n    mean, std = np.mean(logit_ra_values), np.std(logit_ra_values)\n    norm_dist = stats.norm(loc=mean, scale=std)\n    logit_samples = norm_dist.rvs(size=100000)\n    samples = logistic(logit_samples)\n    return samples\n\ndef simulate_p2ra_many(\n    ra_lists=[0.01], sample_populations=[100], n_simulations=1000\n) -> pd.DataFrame:\n    results = defaultdict(list)\n    for sample_pop in sample_populations:\n        for _ in range(n_simulations):\n            results[sample_pop].append(simulate_p2ra(sample_pop, ra_lists))\n    for key, values in results.items():\n        results[key] = sorted(values)\n    df = pd.DataFrame(results)\n    return df\n\n\ndef simulate_p2ra(sample_pop=100, ra_lists=[0.01]):\n    target_incidence_p_w = 0.01\n    shedding_duration_w = 2.4\n\n    prevalence = target_incidence_p_w * shedding_duration_w\n    n_sick = np.random.poisson(sample_pop * prevalence)\n\n    if n_sick == 0:\n        return 0\n    ra_sick = 0\n    for _ in range(n_sick):\n        observation = np.random.choice(ra_lists)\n        ra_sick += observation\n    # TODO: Simplify and rename.\n    ra_sick = ra_sick / n_sick\n    relative_abundance = n_sick / sample_pop * ra_sick\n\n    return relative_abundance\n\n\n\ndef return_fig_2_dfs():\n    # TODO: Check indexing operations.\n    swab_df = pd.concat([study_p2ra_df, composite_p2ra_df], ignore_index=True)\n    swab_df.reset_index(drop=True, inplace=True)\n\n\n    df_ww = pd.DataFrame(\n        {\n            \"Relative Abundance\": df_rothman_ras + df_crits_christoph_ras,\n            \"Subset\": [\"Rothman et al. 2021\"] * len(df_rothman_ras)\n            + [\"Crits-Christoph et al. 2021\"] * len(df_crits_christoph_ras),\n        }\n    )\n    # TODO: Fix names of dfs below (across the entirety of the code.)\n    return swab_df, df_ww\n\n\ndef return_fig_7_dfs():\n    swab_df = pd.concat(\n        [composite_p2ra_df, adjusted_composite_p2ra_df], ignore_index=True\n    )\n    swab_df.reset_index(drop=True, inplace=True)\n    df_ww = pd.DataFrame(\n        {\n            \"Relative Abundance\": df_rothman_ras + df_crits_christoph_ras,\n            \"Subset\": [\"Rothman et al. 2021\"] * len(df_rothman_ras)\n            + [\"Crits-Christoph et al. 2021\"] * len(df_crits_christoph_ras),\n        }\n    )\n\n    return swab_df, df_ww\n\ndef return_ww_p2ra():\n    df_wastewater = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/2024-05-07-fits.tsv\", sep=\"\\t\") # Taken from p2ra-manuscript. Based on the v1 pipeline.\n    df_rothman_ras = df_wastewater[\n        (df_wastewater[\"study\"] == \"rothman\")\n        & (df_wastewater[\"location\"] == \"Overall\")\n        & (df_wastewater[\"pathogen\"] == \"sars_cov_2\")\n    ][\"ra_at_1in100\"].tolist()\n    df_crits_christoph_ras = df_wastewater[\n        (df_wastewater[\"study\"] == \"crits_christoph\")\n        & (df_wastewater[\"location\"] == \"Overall\")\n        & (df_wastewater[\"pathogen\"] == \"sars_cov_2\")\n    ][\"ra_at_1in100\"].tolist()\n    # TODO: Use named tuple here.\n    return df_rothman_ras, df_crits_christoph_ras\n\n\n\ndef plot_medians(ax, medians):\n    patches = ax.collections\n    for patch, median in zip(patches, medians):\n        for path in patch.get_paths():\n            vertices = path.vertices\n            x_mid = median\n            closest_x = min(vertices[:, 0], key=lambda x: abs(x - x_mid))\n            y_upper = max(vertices[vertices[:, 0] == closest_x, 1])\n            y_lower = min(vertices[vertices[:, 0] == closest_x, 1])\n            ax.plot([x_mid, x_mid], [y_lower, y_upper], color=\"white\", linewidth=1.5)\n\n\n# Generate p2ra values one time before figures are created.\nstudies = return_studies()\nstudy_dfs = studies.values()\nSWAB_STUDY_TITLES = studies.keys()\ncomposite_p2ra_df = return_composite_p2ra()\nadjusted_composite_p2ra_df = return_adjusted_composite_p2ra()\nstudy_p2ra_df = return_study_p2ra()\ndf_rothman_ras, df_crits_christoph_ras = return_ww_p2ra()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n2.2724999999999995\n```\n:::\n:::\n\n\n# Summary\n\n * Respiratory swab sampling is central to infectious disease surveillance, but most such programs focus on targeted identification of specific pathogens. At the NAO, we’re interested in how a swab-based program would perform for more agnostic detection of novel pathogens.\n * To evaluate this, we used published metagenomic sequencing data from SARS-CoV-2 patients to predict the relative abundance of a SARS-CoV-2-like novel pathogen in sequencing data from pooled respiratory swabs collected in public places.\n * Evaluating and contextualizing these datasets, we find the following:\n    * The sensitivity of pooled swab sampling and sequencing appears superior to wastewater sampling for a SARS-CoV-2 like pathogen. A composite of four studies gives a relative abundance of \n\n\n\n\n\n# Introduction\n\n...\n\n# Estimating sampling sensitivity with SARS-CoV-2 sequencing data\n\n...\n\n::: {#35b38467 .cell execution_count=3}\n``` {.python .cell-code}\nstudies = return_studies()\n\n\nfig, axs = plt.subplots(2, 2, figsize=(10, 8), dpi=900)\n\nfor study_df, study_title in zip(studies.values(), studies.keys()):\n    study_df[\"study\"] = study_title\n    studies[study_title] = study_df\n\ndf_np_babiker = studies[\"Babiker et al. 2020\"]\ndf_np_rodriguez = studies[\"Rodriguez et al. 2021\"]\ndf_op_lu = studies[\"Lu et al. 2021\"]\ndf_np_mostafa = studies[\"Mostafa et al. 2020\"]\n\n# TODO: Resolve print statements.\nfor study_df in df_np_babiker, df_np_rodriguez, df_op_lu, df_np_mostafa:\n    print(\n        study_df[\"study\"].unique(),\n        f\"Relative Abundance: {gmean(study_df['scv2_ra'])}\",\n        f\"qPCR CT: {gmean(study_df['scv2_ct'])}\",\n    )\n\ncomposite_df = pd.concat([df_op_lu, df_np_babiker, df_np_mostafa, df_np_rodriguez])\n\nviridis_palette = sns.color_palette(\"viridis\", n_colors=composite_df[\"study\"].nunique())\n\nsns.histplot(\n    ax=axs[0, 0],\n    data=composite_df,\n    x=\"scv2_ra\",\n    hue=\"study\",\n    palette=viridis_palette,\n    bins=30,\n    log_scale=True,\n    element=\"bars\",\n    linewidth=0,\n    multiple=\"stack\",\n    legend=False,\n)\n\naxs[0, 0].set_title(\"a\", x=-0.08, y=1.0, ha=\"left\", fontsize=10, fontweight=\"bold\")\naxs[0, 0].set_ylabel(\"Count\")\naxs[0, 0].set_xlabel(\"Relative Abundance\")\naxs[0, 0].tick_params(axis=\"x\", which=\"minor\", bottom=False)\n\nsns_default = sns.color_palette(n_colors=composite_df[\"patient_status\"].nunique())\nsns.histplot(\n    ax=axs[0, 1],\n    data=composite_df,\n    x=\"scv2_ra\",\n    hue=\"patient_status\",\n    palette=sns_default,\n    bins=30,\n    log_scale=True,\n    element=\"bars\",\n    linewidth=0,\n    multiple=\"stack\",\n    legend=False,\n)\naxs[0, 1].set_title(\"b\", x=-0.08, y=1.0, ha=\"left\", fontsize=10, fontweight=\"bold\")\naxs[0, 1].set_ylabel(\"Count\")\naxs[0, 1].set_xlabel(\"Relative Abundance\")\naxs[0, 1].tick_params(axis=\"x\", which=\"minor\", bottom=False)\n\nsns.scatterplot(\n    ax=axs[1, 0],\n    data=composite_df,\n    x=\"scv2_ra\",\n    y=\"scv2_ct\",\n    hue=\"study\",\n    style=\"study\",\n    palette=viridis_palette,\n)\naxs[1, 0].set_title(\"c\", x=-0.08, y=1.0, ha=\"left\", fontsize=10, fontweight=\"bold\")\naxs[1, 0].set_xlabel(\"Relative Abundance\")\naxs[1, 0].set_ylabel(\"qPCR cycle threshold value\")\naxs[1, 0].set_xscale(\"log\")\n\naxs[1, 0].tick_params(axis=\"x\", which=\"minor\", bottom=False)\n\nsns.move_legend(\n    axs[1, 0],\n    \"lower center\",\n    bbox_to_anchor=(0.5, -0.44),\n    ncol=2,\n    title=None,\n    frameon=False,\n    fontsize=11,\n    markerscale=2,\n)\n\nsns.scatterplot(\n    ax=axs[1, 1],\n    data=composite_df,\n    x=\"scv2_ra\",\n    y=\"scv2_ct\",\n    hue=\"patient_status\",\n    style=\"patient_status\",\n    palette=sns_default,\n)\naxs[1, 1].set_title(\"d\", x=-0.08, y=1.0, ha=\"left\", fontsize=10, fontweight=\"bold\")\naxs[1, 1].set_xlabel(\"Relative Abundance\")\naxs[1, 1].set_ylabel(\"qPCR cycle threshold value\")\naxs[1, 1].set_xscale(\"log\")\n\naxs[1, 1].tick_params(axis=\"x\", which=\"minor\", bottom=False)\n\nsns.move_legend(\n    axs[1, 1],\n    \"lower center\",\n    bbox_to_anchor=(0.5, -0.54),\n    ncol=2,\n    title=None,\n    frameon=False,\n    fontsize=11,\n    markerscale=1.7,\n)\n\nfor ax in axs.flat:\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.tick_params(axis=\"y\", which=\"both\", left=False, right=False, labelleft=True)\nplt.tight_layout()\n#plt.savefig(\"fig/fig_1.png\", dpi=900)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Babiker et al. 2020'] Relative Abundance: 0.00020944604802700337 qPCR CT: 23.91917458075545\n['Rodriguez et al. 2021'] Relative Abundance: 0.0007017796848798247 qPCR CT: 25.608784312331768\n['Lu et al. 2021'] Relative Abundance: 0.0026954545743760336 qPCR CT: 30.659062534215675\n['Mostafa et al. 2020'] Relative Abundance: 0.000145860470857488 qPCR CT: 19.191571913124292\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure 1:** SARS-CoV-2 qPCR CT vs SARS-CoV-2 relative abundance **(a, c)** Data across studies **(b,d)** Data across patient types.](index_files/figure-html/cell-4-output-2.png){}\n:::\n:::\n\n\n...\n\n::: {#bda2cc53 .cell execution_count=4}\n``` {.python .cell-code}\ndef return_fig_2():\n    df_swab, df_ww = return_fig_2_dfs()\n    for subset in df_swab[\"Subset\"].unique():\n        for swab_sample_size in SWAB_SAMPLE_SIZES:\n            subset_df = df_swab.query(\n                \"Subset == @subset and `Sample Size` == @swab_sample_size\"\n            )\n            median = subset_df[\"Relative Abundance\"].median()\n            zero_count_fraction = (subset_df[\"Relative Abundance\"] == 0).mean()\n            print(\n                f\"Subset: {subset}, Sample Size: {swab_sample_size}, Fraction of Zero Counts: {zero_count_fraction}, Median: {median}\"\n            )\n\n    df_ww[\"Relative Abundance\"] = np.log10(df_ww[\"Relative Abundance\"])\n    with np.errstate(divide='ignore'):\n        df_swab[\"Relative Abundance\"] = np.log10(df_swab[\"Relative Abundance\"])\n    fig, axs = plt.subplots(\n        2, 1, figsize=(8, 6), dpi=900, gridspec_kw={\"height_ratios\": [3, 1]}\n    )\n    fig.subplots_adjust(hspace=0.4)\n    colors = sns.color_palette(\"viridis\", len(SWAB_SAMPLE_SIZES))\n\n    sns.violinplot(\n        x=\"Relative Abundance\",\n        y=\"Subset\",\n        ax=axs[0],\n        hue=\"Sample Size\",\n        palette=colors,\n        data=df_swab,\n        linewidth=0,\n        bw_adjust=1.5,\n        dodge=0.4,\n        cut=0.5,\n    )\n\n    swab_medians_logged = []\n\n    for subset in df_swab[\"Subset\"].unique():\n        for swab_sample_size in SWAB_SAMPLE_SIZES:\n            subset_df = df_swab.query(\n                \"Subset == @subset and `Sample Size` == @swab_sample_size\"\n            )\n            median_logged = subset_df[\"Relative Abundance\"].median()\n            swab_medians_logged.append(median_logged)\n\n    plot_medians(axs[0], swab_medians_logged)\n\n    sns.violinplot(\n        x=\"Relative Abundance\",\n        y=\"Subset\",\n        ax=axs[1],\n        color=\"#aedc31\",\n        data=df_ww,\n        inner=None,\n        linewidth=0,\n        bw_adjust=1.5,\n        width=0.5,\n        dodge=0.2,\n    )\n\n\n    ww_medians_logged = []\n    ww_medians = []\n    for study in df_ww[\"Subset\"].unique():\n        median = np.median(\n            df_ww[(df_ww[\"Subset\"] == study)][\"Relative Abundance\"]\n        )\n\n        ww_medians_logged.append(median)\n        ww_medians.append(10**median)\n\n    plot_medians(axs[1], ww_medians_logged)\n\n    axs[0].set_title(\n        \"a (Swabs)\", x=-0.31, y=0.95, fontsize=10, ha=\"left\", fontweight=\"heavy\"\n    )\n    axs[1].set_title(\n        \"b (Wastewater)\", x=-0.31, y=0.95, fontsize=10, ha=\"left\", fontweight=\"bold\"\n    )\n\n    for ax in axs:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.set_ylabel(\"\")\n        ax.set_yticks(ax.get_yticks())\n        y_labels = [\n            label.get_text().rsplit(\" \", 1)[0]\n            + \"\\n\"\n            + label.get_text().rsplit(\" \", 1)[1]\n            if \" \" in label.get_text()\n            else label.get_text()\n            for label in ax.get_yticklabels()\n        ]\n        ax.set_yticklabels(y_labels)\n\n        ax.tick_params(axis=\"y\", which=\"both\", left=False, right=False, labelleft=True)\n\n    xmin, xmax = -10, 0\n    axs[0].set_xlim(xmin, xmax)\n    axs[1].set_xlim(xmin, xmax)\n\n    for x in np.arange(math.ceil(xmin), 1, 1):\n        axs[0].axvline(\n            x=x, color=\"black\", linestyle=\"--\", linewidth=0.3, alpha=0.2, zorder=-1\n        )\n        axs[1].axvline(\n            x=x, color=\"black\", linestyle=\"--\", linewidth=0.3, alpha=0.2, zorder=-1\n        )\n\n    current_xticks = axs[0].get_xticks()\n    for ax in axs:\n        ax.set_xticks(current_xticks)\n        ax.set_xticklabels(\n            [\n                \"$10^{{{}}}$\".format(int(value)) if value != 0 else \"1\"\n                for value in current_xticks\n            ]\n        )\n    legend = axs[0].legend(\n        title=\"Number of\\nswabs\",\n        loc=\"center left\",\n        bbox_to_anchor=(1, 0.5),\n        ncol=1,\n        frameon=False,\n    )\n    legend._legend_box.align = \"left\"\n\n    plt.tight_layout()\n    #plt.savefig(\"fig/fig_2.png\", dpi=900)\n    #plt.savefig(\"fig/fig_2.pdf\", dpi=900)\n\n\nreturn_fig_2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSubset: Lu et al. 2021, Sample Size: 50, Fraction of Zero Counts: 0.2923, Median: 3.9919973212879665e-05\nSubset: Lu et al. 2021, Sample Size: 100, Fraction of Zero Counts: 0.0895, Median: 0.00024457004847063695\nSubset: Lu et al. 2021, Sample Size: 200, Fraction of Zero Counts: 0.0071, Median: 0.0007141963031498716\nSubset: Babiker et al. 2020, Sample Size: 50, Fraction of Zero Counts: 0.2948, Median: 2.608425865856746e-06\nSubset: Babiker et al. 2020, Sample Size: 100, Fraction of Zero Counts: 0.0887, Median: 1.4164822015050062e-05\nSubset: Babiker et al. 2020, Sample Size: 200, Fraction of Zero Counts: 0.0072, Median: 3.983774423293039e-05\nSubset: Mostafa et al. 2020, Sample Size: 50, Fraction of Zero Counts: 0.3078, Median: 2.2504218650818358e-06\nSubset: Mostafa et al. 2020, Sample Size: 100, Fraction of Zero Counts: 0.0922, Median: 5.593729115084734e-06\nSubset: Mostafa et al. 2020, Sample Size: 200, Fraction of Zero Counts: 0.0074, Median: 9.017376489442461e-06\nSubset: Rodriguez et al. 2021, Sample Size: 50, Fraction of Zero Counts: 0.3035, Median: 7.1176005912149486e-06\nSubset: Rodriguez et al. 2021, Sample Size: 100, Fraction of Zero Counts: 0.0922, Median: 7.865878848539872e-05\nSubset: Rodriguez et al. 2021, Sample Size: 200, Fraction of Zero Counts: 0.0087, Median: 0.00029161303899380886\nSubset: Original Composite Data, Sample Size: 50, Fraction of Zero Counts: 0.2959, Median: 5.538070862155936e-06\nSubset: Original Composite Data, Sample Size: 100, Fraction of Zero Counts: 0.0887, Median: 4.01034721082812e-05\nSubset: Original Composite Data, Sample Size: 200, Fraction of Zero Counts: 0.0069, Median: 0.00013362185709428595\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure 2:** Expected relative abundance at 1% SARS-CoV-2 incidence for **(a)** pooled respiratory swabs and **(b)** wastewater sequencing (data from [Grimm et al. 2024](https://www.medrxiv.org/content/10.1101/2023.12.22.23300450v2)). Violins indicate probability density only over simulations for which relative abundance was >0%; zero-abundance results aren’t plotted but can make up a substantial fraction of results ( ~36% of 50-swab pools, ~13% for 100 swabs, and 2% for 200 swabs). Medians (indicated by white bars) incorporate these zero-abundance results.](index_files/figure-html/cell-5-output-2.png){}\n:::\n:::\n\n\n# Adjusting for confounders\n\n\n...\n\n## Swab type\n\n::: {#5fff6e71 .cell tbl-cap='Comparison of different swab sample types. Adapted from Tsang et al. 2021' execution_count=5}\n``` {.python .cell-code}\ntable = [\n    [\"Nasal swabs (n=1622)\", \"0.87 (0.80–0.93)\", \"0.95 (0.88–0.99)\"],\n    [\"Throat swabs (n=388)\", \"0.75 (0.52–0.92)\", \"0.96 (0.94–0.98)\"],\n    [\"Pooled nasal/throat swabs (n=719)\", \"0.97 (0.93–1.00)\", \"0.99 (0.98–1.00)\"],\n    [\"NP swab (n=7973, includes comparison with saliva)\", \"0.94 (0.91–0.97)\", \"0.99 (0.98–1.00)\"]\n]\n\nMarkdown(tabulate(\n  table,\n  headers=[\"Sample Type\", \"Sensitivity\", \"Negative Predictive Value\"]\n))\n```\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=5}\nSample Type                                        Sensitivity       Negative Predictive Value\n-------------------------------------------------  ----------------  ---------------------------\nNasal swabs (n=1622)                               0.87 (0.80–0.93)  0.95 (0.88–0.99)\nThroat swabs (n=388)                               0.75 (0.52–0.92)  0.96 (0.94–0.98)\nPooled nasal/throat swabs (n=719)                  0.97 (0.93–1.00)  0.99 (0.98–1.00)\nNP swab (n=7973, includes comparison with saliva)  0.94 (0.91–0.97)  0.99 (0.98–1.00)\n:::\n:::\n\n\n::: {#cell-np_nasal_ct_plot .cell execution_count=6}\n``` {.python .cell-code}\ndef return_fig_3():\n    # TODO: Fix the underlying google sheet (one of the two pere's is wrong!)\n    df = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/2024-06-18-np-nasal-ct.tsv\", sep=\"\\t\", skiprows=1)\n\n    df = df.melt(var_name=\"Study\", value_name=\"CT Difference\")\n\n    pretty_study_names = {\n        \"Patriquin2022\": \"Patriquin et al. 2022\",\n        \"McCulloch2020\": \"McCulloch et al. 2020\",\n        \"Pere2020\": \"Pere et al. 2020\",\n        \"Kojima2020\": \"Kojima et al. 2020\",\n        \"Tu2020\": \"Tu et al. 2020\",\n    }\n\n    df[\"Study\"] = df[\"Study\"].map(pretty_study_names).values\n\n    mean_ct_diff = df.groupby(\"Study\", as_index=False)[\"CT Difference\"].mean()\n    print(mean_ct_diff)\n    print(mean_ct_diff[\"CT Difference\"].mean())\n    fig = plt.figure(figsize=(8, 4), dpi=900)\n\n    colors = sns.color_palette(\"viridis\", len(df[\"Study\"].unique()))\n\n    sns.stripplot(\n        data=df,\n        y=\"Study\",\n        x=\"CT Difference\",\n        hue=\"Study\",\n        jitter=True,\n        zorder=-1,\n        palette=colors,\n        alpha=0.5,\n    )\n    sns.pointplot(\n        data=mean_ct_diff,\n        y=\"Study\",\n        x=\"CT Difference\",\n        linestyles=\"none\",\n        markers=\"d\",\n        color=\"#36454F\",\n        markersize=7,\n        errorbar=None,\n        zorder=1,\n    )\n    plt.legend([], [], frameon=False)\n    plt.ylabel(\"\")\n    plt.xlabel(\"SARS-CoV-2 qPCR CT Δ (NP - Nasal)\")\n    plt.tick_params(axis=\"y\", which=\"both\", left=False, right=False, labelleft=True)\n\n    x_min, x_max = plt.xlim()\n\n    plt.text(x_max / 2, -0.6, \"Favors Nasal\", fontsize=10, color=\"black\", ha=\"center\")\n    plt.text(\n        x_min / 2, -0.6, \"Favors Nasopharyngeal\", fontsize=10, color=\"black\", ha=\"center\"\n    )\n    x_min = math.ceil(x_min / 5) * 5\n    x_max = math.ceil(x_max / 5) * 5\n\n    x_marks = np.arange(x_min, x_max, 2.5)\n    for x in x_marks:\n        if x == 0:\n            continue\n        plt.axvline(x=x, color=\"grey\", linestyle=\"--\", alpha=0.5, linewidth=0.5, zorder=-2)\n\n    plt.axvline(x=0, color=\"red\", linestyle=\"--\", alpha=0.5, zorder=-2)\n\n    plt.gca().spines[\"right\"].set_visible(False)\n    plt.gca().spines[\"top\"].set_visible(False)\n    plt.gca().spines[\"left\"].set_visible(False)\n    plt.tight_layout()\n\n    #plt.savefig(\"fig/fig_3.png\", dpi=900)\n\n\n\nreturn_fig_3()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   Study  CT Difference\n0     Kojima et al. 2020      -3.899565\n1  McCulloch et al. 2020      -1.550188\n2  Patriquin et al. 2022      -3.045965\n3       Pere et al. 2020       0.977222\n4         Tu et al. 2020       0.378733\n-1.4279524527735736\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure 3:** Nasal swabs vs NP swabs. Data from Patriquin et al. 2022, McCulloch et al. 2020, Pere et al. 2020, Kojima et al. 2020, and Tu et al. 2020. Patriquin et al. 2022 and Pere et al. 2020 performed professional collection of both NP and nasal swabs; other studies performed professional collection of NP swabs but had patients collect nasal swabs themselves.](index_files/figure-html/np_nasal_ct_plot-output-2.png){#np_nasal_ct_plot}\n:::\n:::\n\n\n::: {#0b5bb4d7 .cell execution_count=7}\n``` {.python .cell-code}\ndef return_fig_4():\n    df = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/goodall-op-nasal-ct.tsv\", sep=\"\\t\", skiprows=1)\n    pretty_study_names = {\n        \"Goodall2022\": \"Goodall et al. 2022\",\n    }\n    df = df.melt(var_name=\"Study\", value_name=\"CT Difference\")\n    df[\"Study\"] = df[\"Study\"].map(pretty_study_names).values\n    mean_ct_diff = df.groupby(\"Study\", as_index=False)[\"CT Difference\"].mean()\n    # TODO: Resolve print statement\n    print(mean_ct_diff)\n    fig, ax = plt.subplots(figsize=(8, 1.65), dpi=900)\n\n    viridis = sns.color_palette(\"viridis\", 1)\n    sns.stripplot(\n        data=df,\n        y=\"Study\",\n        x=\"CT Difference\",\n        hue=\"Study\",\n        jitter=True,\n        zorder=-1,\n        ax=ax,\n        alpha=0.8,\n        palette=viridis,\n    )\n    sns.pointplot(\n        data=mean_ct_diff,\n        y=\"Study\",\n        x=\"CT Difference\",\n        linestyles=\"none\",\n        markers=\"d\",\n        color=\"#36454F\",\n        markersize=8,\n        errorbar=None,\n        zorder=1,\n        ax=ax,\n    )\n    ax.legend([], [], frameon=False)\n\n    ax.set_ylabel(\"\")\n    ax.set_xlabel(\"SARS-CoV-2 qPCR CT Δ (OP - Nasal)\")\n    ax.tick_params(axis=\"y\", which=\"both\", left=False, right=False, labelleft=True)\n    x_min, x_max = ax.get_xlim()\n\n    ax.text(x_max / 2, -0.6, \"Favors Nasal\", fontsize=9, color=\"black\", ha=\"center\")\n    ax.text(\n        x_min / 2, -0.6, \"Favors Oropharyngeal\", fontsize=9, color=\"black\", ha=\"center\"\n    )\n\n    x_min = math.ceil(x_min / 5) * 5\n    x_max = math.ceil(x_max / 5) * 5\n\n    x_marks = np.arange(x_min, x_max, 2.5)\n    for x in x_marks:\n        if x == 0:\n            continue\n        ax.axvline(\n            x=x, color=\"grey\", linestyle=\"--\", alpha=0.5, linewidth=0.5, zorder=-2\n        )\n    ax.axvline(x=0, color=\"red\", linestyle=\"--\", alpha=0.5, zorder=-2)\n\n    ax.axhline(y=0.5, color=\"grey\", linestyle=\"--\", alpha=0.5, linewidth=0.5)\n\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"left\"].set_visible(False)\n    plt.tight_layout()\n    #plt.savefig(\"fig/fig_4.png\", dpi=900)\n    plt.show()\n\n\nreturn_fig_4()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                 Study  CT Difference\n0  Goodall et al. 2022       0.988793\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure 4:** Nasal swabs vs Oro-pharyngeal swabs. Data from Goodall et al. 2022.](index_files/figure-html/cell-8-output-2.png){}\n:::\n:::\n\n\n::: {#8fbfb05a .cell execution_count=8}\n``` {.python .cell-code}\n# Figure not shown in the report\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# Source: https://www.medrxiv.org/content/10.1101/2020.05.05.20084889v1.full#:~:text=Comparing%20the%20samples,respectively%20(p%3E0.09).\ndata = {\n    \"E_NP\": {\"median\": 25.5, \"10th\": 20.5, \"90th\": 29.5},\n    \"E_Nasal\": {\"median\": 27.6, \"10th\": 24.7, \"90th\": 32.4},\n    \"E_Throat\": {\"median\": 28.7, \"10th\": 23.5, \"90th\": 34.2},\n    \"RdRp_NP\": {\"median\": 27.9, \"10th\": 23.5, \"90th\": 32.4},\n    \"RdRp_Nasal\": {\"median\": 30.5, \"10th\": 27.5, \"90th\": 35.0},\n    \"RdRp_Throat\": {\"median\": 31.3, \"10th\": 26.5, \"90th\": 35.5},\n}\n\n\ndef calculate_mean_std(median, p10, p90):\n    mean = median\n    std = (p90 - p10) / (2 * norm.ppf(0.9))\n    norm_dist = norm(mean, std)\n    arrived_p10 = norm_dist.ppf(0.1)\n    arrived_p90 = norm_dist.ppf(0.9)\n    if abs(p10 - arrived_p10) > 1 or abs(p90 - arrived_p90) > 1:\n        print(f\"Warning: p10 or p90 values are not within one point of the arrived percentiles. p10: {p10}, arrived_p10: {arrived_p10}, p90: {p90}, arrived_p90: {arrived_p90}\")\n    return mean, std\n\n\nx = np.linspace(10, 40, 1000)\n\ndistributions = []\n\nfor key, values in data.items():\n    mean, std = calculate_mean_std(values[\"median\"], values[\"10th\"], values[\"90th\"])\n    distribution = np.random.normal(mean, std, 100000)\n\n    distributions.append(distribution)\n\nmean_of_means = {}\nswab_types = [\"NP\", \"Nasal\", \"Throat\"]\n\n# Not doing a weighted average because there are approximately the same numbers for both qPCR targets.\nfor swab in swab_types:\n    swab_means = [\n        np.mean(distribution)\n        for key, distribution in zip(data.keys(), distributions)\n        if swab in key\n    ]\n    mean_of_means[swab] = np.mean(swab_means)\n\nprint(mean_of_means)\n\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{'NP': 26.701626801330207, 'Nasal': 29.057303467210872, 'Throat': 29.994402555833233}\n```\n:::\n:::\n\n\n## Patient Status and Disease Onset\n\n::: {#cell-target-studies-patient-composition .cell execution_count=9}\n``` {.python .cell-code}\ndef return_fig_5():\n    studies = return_studies()\n    df_np_babiker = studies[\"Babiker et al. 2020\"]\n    df_np_rodriguez = studies[\"Rodriguez et al. 2021\"]\n    df_op_lu = studies[\"Lu et al. 2021\"]\n    df_np_mostafa = studies[\"Mostafa et al. 2020\"]\n\n    order = [\"Outpatient\", \"Inpatient\", \"Required\\nventilator\", \"ICU\", \"Unknown\"]\n\n    lu_counts = df_op_lu[\"patient_status\"].value_counts().reindex(order)\n    babiker_counts = df_np_babiker[\"patient_status\"].value_counts().reindex(order)\n    mostafa_counts = df_np_mostafa[\"patient_status\"].value_counts().reindex(order)\n    rodriguez_counts = (\n        df_np_rodriguez[\"patient_status\"].value_counts().reindex(order).dropna())\n\n    print(lu_counts, babiker_counts, mostafa_counts, rodriguez_counts)\n\n    fig, axs = plt.subplots(\n        1, 4, figsize=(10, 4), width_ratios=[0.7, 1.5, 2.4, 4], sharey=True, dpi=800\n    )\n\n    colors = sns.color_palette(\"viridis\", 10)\n    color_dict = {\n        \"Outpatient\": colors[9],\n        \"Inpatient\": colors[3],\n        \"Required\\nventilator\": colors[5],\n        \"ICU\": colors[0],\n        \"Unknown\": colors[7],\n    }\n\n    axs[0].bar(\n        lu_counts.index, lu_counts.values, color=color_dict[\"Inpatient\"], width=0.5\n    )\n    axs[0].set_title(\"Lu et al. 2021\", fontsize=10)\n    axs[0].set_ylabel(\"Count\")\n\n    axs[1].bar(\n        babiker_counts.index,\n        babiker_counts.values,\n        color=[color_dict[x] for x in babiker_counts.index],\n        width=0.8,\n    )\n    axs[1].set_title(\"Babiker et al. 2020\", fontsize=10)\n\n    axs[3].bar(\n        mostafa_counts.index,\n        mostafa_counts.values,\n        color=[color_dict[x] for x in mostafa_counts.index],\n    )\n    axs[3].set_title(\"Mostafa et al. 2020\", fontsize=10)\n    axs[3].set_ylim(0, max(mostafa_counts.values) + 10)\n    axs[3].set_yticks(np.arange(0, max(mostafa_counts.values) + 30, 10))\n\n    axs[2].bar(\n        rodriguez_counts.index,\n        rodriguez_counts.values,\n        color=[color_dict[x] for x in rodriguez_counts.index],\n    )\n    axs[2].set_title(\"Rodriguez et al. 2021\", fontsize=10)\n    axs[2].set_ylim(0, max(rodriguez_counts.values) + 5)\n    axs[2].set_yticks(np.arange(0, max(rodriguez_counts.values) + 10, 5))\n\n    for ax in axs:\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"top\"].set_visible(False)\n        ax.tick_params(axis=\"y\", which=\"both\", left=False, right=False, labelleft=True)\n        ax.tick_params(\n            axis=\"x\",\n            which=\"both\",\n            top=False,\n            bottom=False,\n            labeltop=False,\n            labelbottom=True,\n            labelsize=9,\n        )\n        for x in np.arange(0, 50, 10):\n            ax.axhline(\n                y=x, color=\"grey\", linestyle=\"--\", alpha=0.5, linewidth=0.5, zorder=-1\n            )\n\n    plt.tight_layout()\n    #plt.savefig(\"fig/fig_5.png\", dpi=800)\n    plt.show()\n\n\nreturn_fig_5()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npatient_status\nOutpatient               NaN\nInpatient               16.0\nRequired\\nventilator     NaN\nICU                      NaN\nUnknown                  NaN\nName: count, dtype: float64 patient_status\nOutpatient              10.0\nInpatient               34.0\nRequired\\nventilator     NaN\nICU                      NaN\nUnknown                  NaN\nName: count, dtype: float64 patient_status\nOutpatient              16\nInpatient                3\nRequired\\nventilator     1\nICU                      1\nUnknown                  5\nName: count, dtype: int64 patient_status\nOutpatient    42.0\nInpatient     17.0\nICU           44.0\nName: count, dtype: float64\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure 5:** Patient composition of Lu et al. 2021, Babiker et al. 2020, Mostafa et al. 2020, and Rodriguez et al. 2021.](index_files/figure-html/target-studies-patient-composition-output-2.png){#target-studies-patient-composition}\n:::\n:::\n\n\n::: {#f5042cc2 .cell execution_count=10}\n``` {.python .cell-code}\n# TODO: Hide output.\nstudies = return_studies()\ndf_np_babiker = studies[\"Babiker et al. 2020\"]\ndf_np_rodriguez = studies[\"Rodriguez et al. 2021\"]\ndf_op_lu = studies[\"Lu et al. 2021\"]\ndf_np_mostafa = studies[\"Mostafa et al. 2020\"]\n\norder = [\"Outpatient\", \"Inpatient\", \"Required\\nventilator\", \"ICU\", \"Unknown\"]\n\nlu_counts = df_op_lu[\"patient_status\"].value_counts().reindex(order)\nbabiker_counts = df_np_babiker[\"patient_status\"].value_counts().reindex(order)\nmostafa_counts = df_np_mostafa[\"patient_status\"].value_counts().reindex(order)\n# TODO: Why the drop na in rodriguez? If there are NAs they should be Unknown.\nrodriguez_counts = (\n    df_np_rodriguez[\"patient_status\"].value_counts().reindex(order).dropna()\n)\n\ncomposite_counts = pd.DataFrame(\n    {\n        \"Lu\": lu_counts,\n        \"Babiker\": babiker_counts,\n        \"Mostafa\": mostafa_counts,\n        \"Rodriguez\": rodriguez_counts,\n    }\n)\n\ntotal_counts_across_studies = composite_counts.sum(axis=1)\nshare_outpatients_across_studies = (\n    total_counts_across_studies[\"Outpatient\"] / total_counts_across_studies.sum()\n)\n\nprint(total_counts_across_studies, total_counts_across_studies.sum())\nprint(\n    f\"Share of Outpatients across all studies: {share_outpatients_across_studies:.2%}\"\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\npatient_status\nICU                     45.0\nInpatient               70.0\nOutpatient              68.0\nRequired\\nventilator     1.0\nUnknown                  5.0\ndtype: float64 189.0\nShare of Outpatients across all studies: 35.98%\n```\n:::\n:::\n\n\n::: {#cell-knudtzen-days-status-ct .cell execution_count=11}\n``` {.python .cell-code}\ndef return_fig_6():\n    df_knudtzen_ct_days = pd.read_csv(\"../data/2024-06-17-swab-sensitivity/knudtzen2021_ct_days.tsv\", sep=\"\\t\", skiprows=1)\n    df_knudtzen_ct_days[\"Patient Status\"] = df_knudtzen_ct_days[\"Patient Status\"].astype(\n        \"category\"\n    )\n    df_knudtzen_ct_days[\"Day\"] = df_knudtzen_ct_days[\"Day\"].round()\n    status_to_color = {\n        status: idx\n        for idx, status in enumerate(df_knudtzen_ct_days[\"Patient Status\"].unique())\n    }\n    colors = sns.color_palette(\"viridis\", len(status_to_color))\n\n    reg = smf.ols('CT ~ Day + Q(\"Patient Status\")', data=df_knudtzen_ct_days)\n    results = reg.fit()\n    #print(results.summary())\n\n    fig, ax = plt.subplots(figsize=(6, 3.5), dpi=900)\n    for status, color in zip(df_knudtzen_ct_days[\"Patient Status\"].unique(), colors):\n        subset = df_knudtzen_ct_days[df_knudtzen_ct_days[\"Patient Status\"] == status]\n        plt.scatter(\n            subset[\"Day\"],\n            subset[\"CT\"],\n            c=[color],\n            label=status,\n            edgecolors=\"w\",\n            linewidths=0.5,\n        )\n\n        line_x_values = range(int(subset[\"Day\"].min()), int(subset[\"Day\"].max()) + 1)\n        line_y_values = results.predict(\n            pd.DataFrame(\n                {\"Day\": line_x_values, \"Patient Status\": [status] * len(line_x_values)}\n            )\n        )\n\n        plt.plot(line_x_values, line_y_values, color=color, linestyle=\"--\", linewidth=2)\n\n    plt.xlabel(\"Days from symptom onset\")\n    plt.ylabel(\"qPCR-CT Value\")\n    plt.legend(\n        title=\"\", loc=\"upper center\", bbox_to_anchor=(0.5, -0.15), ncol=2, frameon=False\n    )\n\n\n    for val in range(0, 20, 5):\n        ax.axvline(x=val, color=\"grey\", linestyle=\"--\", linewidth=0.5, alpha=0.3, zorder=-1)\n\n    for val in range(15, 40, 5):\n        ax.axhline(y=val, color=\"grey\", linestyle=\"--\", linewidth=0.5, alpha=0.3, zorder=-1)\n\n    ax.set_xticks(range(0, int(df_knudtzen_ct_days[\"Day\"].max()) + 1, 5))\n\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"top\"].set_visible(False)\n\n\n    plt.tight_layout()\n    #plt.savefig(\"fig/knudtzen_ct_days.png\", dpi=900)\n    plt.show()\n\nreturn_fig_6()\n```\n\n::: {.cell-output .cell-output-display}\n![**Figure 6:** Relationship between days since symptom onset and viral load. Data extracted from [Knudtzen et al. 2021, Figure 3A.](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0258421)](index_files/figure-html/knudtzen-days-status-ct-output-1.png){#knudtzen-days-status-ct}\n:::\n:::\n\n\n## Asymptomatic individuals\n\n\n...\n\n\n# Modeling the sensitivity of a pooled swab sampling program\n\n::: {#cell-fig_7 .cell execution_count=12}\n``` {.python .cell-code}\ndef return_fig_7():\n    # TODO: insert line break for original comp data label.\n    plot_df_swab, plot_df_ww = return_fig_7_dfs()\n    plot_df_ww[\"Relative Abundance\"] = np.log10(plot_df_ww[\"Relative Abundance\"])\n    plot_df_swab[\"Relative Abundance\"] = np.log10(plot_df_swab[\"Relative Abundance\"])\n\n    fig, axs = plt.subplots(\n        2,\n        1,\n        figsize=(8, 4),\n        dpi=900,\n        gridspec_kw={\"height_ratios\": [1.5, 1]},\n    )\n    fig.subplots_adjust(hspace=0.4)\n    colors = sns.color_palette(\"viridis\", 3)\n    sns.violinplot(\n        x=\"Relative Abundance\",\n        y=\"Subset\",\n        ax=axs[0],\n        hue=\"Sample Size\",\n        palette=colors,\n        data=plot_df_swab,\n        linewidth=0,\n        bw_adjust=1.5,\n        dodge=0.4,\n        cut=1,\n    )\n    swab_medians_logged = []\n    for subset in plot_df_swab[\"Subset\"].unique():\n        for swab_sample_size in SWAB_SAMPLE_SIZES:\n            median = np.median(\n                plot_df_swab[\n                    (plot_df_swab[\"Subset\"] == subset)\n                    & (plot_df_swab[\"Sample Size\"] == swab_sample_size)\n                ][\"Relative Abundance\"]\n            )\n            swab_medians_logged.append(median)\n\n    plot_medians(axs[0], swab_medians_logged)\n    sns.violinplot(\n        x=\"Relative Abundance\",\n        y=\"Subset\",\n        ax=axs[1],\n        color=\"#aedc31\",\n        data=plot_df_ww,\n        linewidth=0,\n        bw_adjust=1.5,\n        width=0.5,\n        dodge=0.4,\n    )\n    ww_medians_logged = []\n    ww_medians = []\n    for study in plot_df_ww[\"Subset\"].unique():\n        median = np.median(\n            plot_df_ww[(plot_df_ww[\"Subset\"] == study)][\"Relative Abundance\"]\n        )\n\n        ww_medians_logged.append(median)\n        ww_medians.append(10**median)\n    plot_medians(axs[1], ww_medians_logged)\n\n    axs[0].set_title(\n        \"a (Swabs)\", x=-0.31, y=0.95, fontsize=10, ha=\"left\", fontweight=\"heavy\"\n    )\n    axs[1].set_title(\n        \"b (Wastewater)\", x=-0.31, y=0.95, fontsize=10, ha=\"left\", fontweight=\"bold\"\n    )\n    for ax in axs:\n        ax.spines[\"top\"].set_visible(False)\n        ax.spines[\"right\"].set_visible(False)\n        ax.spines[\"left\"].set_visible(False)\n        ax.set_ylabel(\"\")\n        if ax == axs[1]:\n            y_labels = [\n                (\n                    label.get_text().rsplit(\" \", 1)[0]\n                    + \"\\n\"\n                    + label.get_text().rsplit(\" \", 1)[1]\n                    if \" \" in label.get_text()\n                    else label.get_text()\n                )\n                for label in ax.get_yticklabels()\n            ]\n            ax.set_yticks(ax.get_yticks())\n            ax.set_yticklabels(y_labels)\n        ax.tick_params(axis=\"y\", which=\"both\", left=False, right=False, labelleft=True)\n    xmin, xmax = -10, 0\n    for x in np.arange(math.ceil(xmin), 1, 1):\n        axs[0].axvline(\n            x=x, color=\"black\", linestyle=\"--\", linewidth=0.3, alpha=0.2, zorder=-1\n        )\n        axs[1].axvline(\n            x=x, color=\"black\", linestyle=\"--\", linewidth=0.3, alpha=0.2, zorder=-1\n        )\n    for ax in axs:\n        ax.set_xlim(xmin, xmax)\n        current_xticks = ax.get_xticks()\n        ax.set_xticks(current_xticks)\n        ax.set_xticklabels(\n            [\n                \"$10^{{{}}}$\".format(int(value)) if value != 0 else \"1\"\n                for value in current_xticks\n            ]\n        )\n    legend = axs[0].legend(\n        title=\"Number of\\nswabs\",\n        loc=\"center left\",\n        bbox_to_anchor=(1, 0.5),\n        ncol=1,\n        frameon=False,\n    )\n    legend._legend_box.align = \"left\"\n    plt.tight_layout()\n    #plt.savefig(\"fig/fig_7.png\", dpi=900)\n\n\nreturn_fig_7()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/Users/simongrimm/code/p2ra/venv/lib/python3.10/site-packages/pandas/core/arraylike.py:396: RuntimeWarning:\n\ndivide by zero encountered in log10\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure 7:** Data adjusted to 35% asymptomatic individuals, sampled with nasal swabs. Violins indicate probability density only over simulations for which relative abundance was >0%; zero-abundance results aren’t plotted but can make up a substantial fraction of results ( ~36% of 50-swab pools, ~13% for 100 swabs, and 2% for 200 swabs). Medians (indicated by white bars) incorporate these zero-abundance results. Data of ICU and ventilated patients is dropped in the adjusted dataset.](index_files/figure-html/fig_7-output-2.png){#fig_7}\n:::\n:::\n\n\n::: {#ad7705de .cell tbl-cap='Comparison of swab sampling relative abundance to wastewater relative abundance at 1% weekly incidence.' execution_count=13}\n``` {.python .cell-code}\ndef create_table_3():\n    plot_df_swab, plot_df_ww = return_fig_7_dfs()\n\n    table_data = defaultdict()\n\n    for subset in plot_df_swab[\"Subset\"].unique():\n        for swab_sample_size in SWAB_SAMPLE_SIZES:\n            subset_df = plot_df_swab.query(\n                \"Subset == @subset and `Sample Size` == @swab_sample_size\"\n            )\n            median, iqr = subset_df[\"Relative Abundance\"].median(), subset_df[\n                \"Relative Abundance\"\n            ].quantile(0.75) - subset_df[\"Relative Abundance\"].quantile(0.25)\n            table_data[(subset, swab_sample_size)] = (median, iqr)\n\n    ww_medians = []\n\n    for study in plot_df_ww[\"Subset\"].unique():\n        median = np.median(\n            plot_df_ww[(plot_df_ww[\"Subset\"] == study)][\"Relative Abundance\"]\n        )\n        ww_medians.append(median)\n\n    avg_median = gmean(ww_medians)\n\n    columns = None\n    table_output = []\n\n    for key, (median, iqr) in table_data.items():\n        sample, swab_sample_size = key\n        sample = sample.replace(\"\\n\", \" \")\n\n        #if columns is None:\n        #    columns = \"Sample Type\\tSample Size\\tMedian\\tIQR\\tFold difference vs Rothman\\tFold difference vs Crits-Christoph\\tFold difference vs Average\"\n        #    table_output.append(columns)\n\n        rothman_median = ww_medians[0]\n        crits_median = ww_medians[1]\n        diff_to_rothman = round((median / rothman_median) / 5) * 5\n        diff_to_crits = round((median / crits_median) / 5) * 5\n        diff_to_avg = round((median / avg_median) / 5) * 5\n        table_output.append(\n            f\"{sample}\\t{swab_sample_size}\\t{median:.2e}\\t{iqr:.2e}\\t{diff_to_rothman}\\t{diff_to_crits}\\t{diff_to_avg}\"\n        )\n\n    Markdown(tabulate(\n        table_output,\n        headers=[\"Sample Type\", \"Sample Size\", \"Median\", \"IQR\", \"Fold difference vs Rothman\", \"Fold difference vs Crits-Christoph\", \"Fold difference vs Average\"]\n    ))\n\n\n    #formatted_table = \"\\n\".join(table_output)\n    #Markdown(formatted_table)\n    #print(formatted_table)\n\n\ncreate_table_3()\n```\n:::\n\n\n# Estimating the cost\n\n\n\n\n# Conclusion\n\n\n# Appendix\n\n::: {#cell-fig_s1 .cell execution_count=14}\n``` {.python .cell-code}\ndef return_fig_s1():\n    #TODO: Fix set_ticks issue\n    study_labels = list(return_studies().keys())\n    ra_lists = return_study_ras()\n    composite_ras = return_composite_ras()\n    study_labels.append(\"Composite\")\n    ra_lists.append(composite_ras)\n\n    raw_distributions = []\n    for ras in ra_lists:\n        samples = return_logit_normal_samples(ras)\n        raw_distributions.append(samples)\n\n\n    fig, ax = plt.subplots(1, 1, figsize=(7, 3), dpi=900)\n    log_distributions = [np.log10(distribution) for distribution in raw_distributions]\n    log_rel_abuns = [np.log10(ras) for ras in ra_lists]\n\n    viridis_palette = sns.color_palette(\"viridis\", n_colors=len(study_labels)-1)\n    composite_study_color = \"#aedc31\"\n    viridis_palette.append(composite_study_color)\n\n    sns.violinplot(data=log_distributions, ax=ax, inner=None, palette=viridis_palette, orient='h', zorder=1, linewidth=0.5, cut=0, alpha=1, fill=False, bw_adjust=1.5)\n\n    sns.stripplot(data=log_rel_abuns, ax=ax, jitter=True, palette=viridis_palette, orient='h', alpha=0.7, zorder=2)\n    ax.set_yticks(ax.get_yticks())\n    ax.set_yticklabels(study_labels)\n\n    ax.spines[\"top\"].set_visible(False)\n    ax.spines[\"right\"].set_visible(False)\n    ax.spines[\"left\"].set_visible(False)\n    ax.set_ylabel(\"\")\n\n    y_labels = [\n        (\n            label.get_text().rsplit(\" \", 1)[0]\n            + \"\\n\"\n            + label.get_text().rsplit(\" \", 1)[1]\n            if \" \" in label.get_text()\n            else label.get_text()\n        )\n        for label in ax.get_yticklabels()\n    ]\n\n    ax.tick_params(axis=\"y\", which=\"both\", left=False, right=False, labelleft=True)\n\n    current_xticks = ax.get_xticks()\n    ax.set_xticklabels(\n            [\n                \"$10^{{{}}}$\".format(int(value)) if value != 0 else \"1\"\n                for value in current_xticks\n            ]\n        )\n    xmin, xmax = ax.get_xlim()\n    for x in np.arange(math.ceil(xmin), 1, 1):\n        ax.axvline(\n            x=x, color=\"black\", linestyle=\"--\", linewidth=0.3, alpha=0.2, zorder=-1\n        )\n    ax.set_xlabel(\"Relative Abundance\")\n\n    plt.tight_layout()\n    plt.show()\n    #plt.savefig(\"fig/fig_s1.png\", dpi=900)\n\n\nreturn_fig_s1()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n/var/folders/gm/txqg8t5d57z34sqfjcvpcjj00000gn/T/ipykernel_25768/1084722031.py:48: UserWarning:\n\nset_ticklabels() should only be used with a fixed number of ticks, i.e. after set_ticks() or using a FixedLocator.\n\n```\n:::\n\n::: {.cell-output .cell-output-display}\n![**Figure S1:** Raw relative abundance values and logit-normal distributions for each study.](index_files/figure-html/fig_s1-output-2.png){#fig_s1}\n:::\n:::\n\n\n::: {#75e7a28a .cell execution_count=15}\n``` {.python .cell-code}\ndef create_table_s1():\n    plot_df_swab, plot_df_ww = return_fig_2_dfs()\n\n    table_data = defaultdict()\n\n    for subset in plot_df_swab[\"Subset\"].unique():\n        for swab_sample_size in SWAB_SAMPLE_SIZES:\n            subset_df = plot_df_swab.query(\"Subset == @subset and `Sample Size` == @swab_sample_size\")\n            median = subset_df[\"Relative Abundance\"].median()\n            iqr = subset_df[\"Relative Abundance\"].quantile(0.75) - subset_df[\"Relative Abundance\"].quantile(0.25)\n            table_data[(subset, swab_sample_size)] = (median, iqr)\n\n    ww_medians = []\n\n    for study in plot_df_ww[\"Subset\"].unique():\n        median = np.median(\n            plot_df_ww[(plot_df_ww[\"Subset\"] == study)][\"Relative Abundance\"]\n        )\n        ww_medians.append(median)\n\n    avg_median = gmean(ww_medians)\n    print(avg_median)\n\n    columns = None\n    table_output = []\n\n\n    for key, (median, iqr) in table_data.items():\n        sample, swab_sample_size = key\n        sample = sample.replace(\"\\n\", \" \")\n\n        #if columns is None:\n        #    columns = \"Sample Type\\tSample Size\\tMedian\\tIQR\\tFold difference vs Rothman\\tFold difference vs Crits-Christoph\\tFold difference vs Average\"\n        #    table_output.append(columns)\n\n        rothman_median = ww_medians[0]\n        crits_median = ww_medians[1]\n        diff_to_rothman = round((median / rothman_median) / 5) * 5\n        diff_to_crits = round((median / crits_median) / 5) * 5\n        diff_to_avg = round((median / avg_median) / 5) * 5\n        table_output.append(f\"{sample}\\t{swab_sample_size}\\t{median:.2e}\\t{iqr:.2e}\\t{diff_to_rothman}\\t{diff_to_crits}\\t{diff_to_avg}\")\n\n    Markdown(tabulate(\n        table_output,\n        headers=[\"Sample Type\", \"Sample Size\", \"Median\", \"IQR\", \"Fold difference vs Rothman\", \"Fold difference vs Crits-Christoph\", \"Fold difference vs Average\"]\n    ))\n\ncreate_table_s1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n1.014761246835146e-07\n```\n:::\n:::\n\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {}
  }
}